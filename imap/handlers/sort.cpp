// Copyright Oryx Mail Systems GmbH. All enquiries to info@oryx.com, please.

#include "sort.h"

#include "field.h"
#include "mailbox.h"
#include "threader.h"
#include "imapparser.h"
#include "imapsession.h"


class SortData
    : public Garbage
{
public:
    SortData(): Garbage(), q( 0 ), u( false ) {}

    enum SortCriterionType {
        Arrival,
        Cc,
        Date,
        From,
        Size,
        Subject,
        To,
        Unknown
    };

    class SortCriterion
        : public Garbage {
    public:
        SortCriterion(): t( Unknown ), reverse( false ) {}

        SortCriterionType t;
        bool reverse;
    };

    List<SortCriterion> c;

    Query * q;
    bool u;

    bool usingCriterionType( SortCriterionType );

    void addCondition( String &, class SortCriterion * );
    void addJoin( String &, const String &, const String &, bool );
};


/*! \class Sort sort.h

    The Sort class implements the IMAP SORT extension, which is
    defined in RFC 5256.

    This class subclasses Search in order to take advantage of its
    parser, and operates quite nastily on the Query generated by
    Selector.
*/



/*! Constructs an empty Sort handler. If \a u is true, the SORT
    response will use UIDs, if it's false it will use MSNs.
*/

Sort::Sort( bool u )
    : Search( u ), d( new SortData )
{
    d->u = u;
}


void Sort::parse()
{
    // sort-criteria
    space();
    require( "(" );
    bool x = true;
    while ( x ) {
        uint m = parser()->mark();
        if ( !d->c.isEmpty() )
            space();
        SortData::SortCriterion * c = new SortData::SortCriterion;
        String s = parser()->dotLetters( 2, 7 ).lower();
        if ( s == "reverse" ) {
            space();
            s = parser()->dotLetters( 2, 7 ).lower();
            c->reverse = true;
        }
        if ( s == "arrival" )
            c->t = SortData::Arrival;
        else if ( s == "cc" )
            c->t = SortData::Cc;
        else if ( s == "date" )
            c->t = SortData::Date;
        else if ( s == "from" )
            c->t = SortData::From;
        else if ( s == "size" )
            c->t = SortData::Size;
        else if ( s == "subject" )
            c->t = SortData::Subject;
        else if ( s == "to" )
            c->t = SortData::To;
        if ( ok() && c->t != SortData::Unknown ) {
            if ( !d->usingCriterionType( c->t ) )
                d->c.append( c );
        }
        else {
            parser()->restore( m );
            x = false;
        }
    }
    require( ")" );

    space();

    // search-criteria
    setCharset( astring() );
    space();
    parseKey();
    while ( nextChar() == ' ' ) {
        space();
        parseKey();
    }
    end();
}


/*! This reimplementation hides Search::execute() entirely. */

void Sort::execute()
{
    if ( state() != Executing )
        return;
    if ( !imap() || !imap()->session() || !imap()->session()->mailbox() )
        return;

    if ( d->usingCriterionType( SortData::Subject ) ) {
        Threader * t = imap()->session()->mailbox()->threader();
        if ( !t->updated( true ) ) {
            t->refresh( this );
            return;
        }
    }

    if ( !d->q ) {
        Selector * s = selector();
        s->simplify();
        d->q = s->query( imap()->user(), imap()->session()->mailbox(),
                         imap()->session(), this );
        String t = d->q->string();
        List<SortData::SortCriterion>::Iterator c( d->c );
        while ( c ) {
            d->addCondition( t, c );
            ++c;
        }
        d->q->setString( t );
        d->q->execute();
    }

    if ( !d->q->done() )
        return;

    String s;
    s.reserve( d->q->rows() * 6 );
    s.append( "SORT" );
    Row * r;
    while ( (r=d->q->nextRow()) != 0 ) {
        s.append( " " );
        uint uid = r->getInt( "uid" );
        if ( d->u )
            s.append( fn( uid ) );
        else
            s.append( fn( imap()->session()->msn( uid ) ) );
    }
    respond( s, Untagged );
    finish();
}


void SortData::addCondition( String & t, class SortData::SortCriterion * c )
{
    switch ( c->t ) {
    case Arrival:
        addJoin( t, "", "mm.idate", c->reverse );
        break;
    case Cc:
        addJoin( t,
                 "left join address_fields sccaf on "
                 "(mm.message=sccaf.message and "
                 " sccaf.part='' and sccaf.number=0 and"
                 " sccaf.field=" + fn( HeaderField::Cc ) + ") "
                 "left join addresses scca on (sccaf.address=scca.id) ",
                 "scca.localpart",
                 c->reverse );
        break;
    case Date:
        addJoin( t,
                 "join date_fields sddf on (mm.message=sddf.message) ",
                 "sddf.value",
                 c->reverse );
        break;
    case From:
        addJoin( t,
                 "join address_fields sfaf on "
                 "(mm.message=sfaf.message and "
                 " sfaf.part='' and sfaf.number=0 and"
                 " sfaf.field=" + fn( HeaderField::From ) + ") "
                 "join addresses sfa on (sfaf.address=sfa.id) ",
                 "sfa.localpart",
                 c->reverse );
        break;
    case Size:
        addJoin( t,
                 "join messages m on (m.id=mm.message)",
                 "m.rfc822size",
                 c->reverse );
        break;
    case Subject:
        addJoin( t,
                 "left join thread_members sstm on "
                 "(mm.mailbox=sstm.mailbox and mm.uid=sstm.uid) "
                 "left join threads sst on "
                 "(sstm.thread=sst.id) ",
                 "sst.subject",
                 c->reverse );
        break;
    case To:
        addJoin( t,
                 "left join address_fields staf on "
                 "(mm.message=staf.message and "
                 " staf.part='' and staf.number=0 and"
                 " staf.field=" + fn( HeaderField::To ) + ") "
                 "left join addresses sta on (staf.address=sta.id) ",
                 "sta.localpart",
                 c->reverse );
        break;
    case Unknown:
        break;
    }
}


void SortData::addJoin( String & t,
                        const String & join, const String & orderby,
                        bool desc )
{
    int w = t.find( " where " );
    if ( w < 0 )
        return;
    t = t.mid( 0, w+1 ) + join + t.mid( w+1 );
    int o = t.find( " order by " );
    if ( o < 0 )
        return;
    o += 10;
    int c = t.length();
    while ( c > o && t[c] != ',' )
        c--;
    if ( c > o )
        t = t.mid( 0, c ) + ", " + orderby +
            ( desc ? " desc" : "" ) +
            t.mid( c );
    else
        t = t.mid( 0, o ) + orderby +
            ( desc ? " desc, " : ", " ) +
            t.mid( o );

    // and include orderby in the return list so select distinct
    // doesn't complain. why does select distinct do that anyway?
    int s = t.find( "mm.uid" );
    if ( s < 0 )
        return;
    s += 6;
    t = t.mid( 0, s ) + ", " + orderby + t.mid( s );
}


bool SortData::usingCriterionType( SortCriterionType t )
{
    List<SortCriterion>::Iterator i( c );
    while ( i && i->t != t )
        ++i;
    if ( i )
        return true;
    return false;
}

