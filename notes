The next eight months

  - Message retention
      User interface
      Message identification
      Logging changes to the message
  - aoximport improvements
  - Full text search
  - More documentation
      aox operations guide
      best practice papers
  - Better documentation
  - VIEW improvements
      INTHREAD
      multi-mailbox searches
      miscellaneous
  - Account management
      ACL management
      VIEW management
  - Recording the fate of outgoing mail
  - Proper full-text searching
  - Better exploratory search
  - Useful webmail
  - Address search
      Web UI
      IMAP X-extension
      Exporting to addressbooks


1.13: 2006-11-27

  Eliminate the header_fields that also exist as address_fields or
  date_fields rows, add two new fetchers and clean up the db.


Arnt in Delhi

  Arrive: LH762 2006-12-02 07:30
  Depart: LH763 2006-12-08 09:55

  Let's revisit change 53044.

  Edit the 'aox operations guide' blah and make titles and names for
  lots of web pages.

  The VoF list needs discussion. I'd like to have the next eight monts
  fairly clear, so we'll move aox towards a clear, good, desirable
  vision.

  One evening talking about Perpetual features.


1.14: 2007-01-15

  Deliver submitted mail to a smarthost. We've done most of the hard
  work, we just need to complete it.

  Implement ESEARCH (RFC 4731). Done.

  aox reinject and schema 34.

  (Next: 1.13 items we didn't do, or didn't finish.)

  Sieve.

  Basic administration using the httpd
  Read-only archive pages

  (Next: 1.14 items specified before.)

  Message retention policy

  httpd:
  - TLS support
  - More administration stuff

  Indexing for DOC bodyparts

  aox backup/restore (or similarly helpful procedure)

  LDAP authentication support (but how does this help us?)


1.15: 2007-02-19

  (I moved stuff here from earlier releases so this is now hopelessly
  ambitious --Arnt)

  Memory use improvements

  Message retention policy

  - Soft-quota/archival stuff too?
  - Message arrival tag (for archiving)

  more httpd

  aoximport could be much faster (disable indices, commit several
  thousand messages at a time in one big transaction), but it's a fair
  bit of work (unless aoximport has a private Injector or Injector can
  take a list of Message objets)

  Autoresponder

  Miscellaneous:

  - Database replication support (local mirror)
  - Clean up orphaned bodyparts without locking the table
  - Split the injector transaction into fast and slow parts(?)

  SORT (/THREAD?)


Things we didn't do in 1.10-1.15:

  Full-text search

  LDAP AB? Webmail?


Webmail design

  HTTP has a list of registered page handler functions. It uses a
  somewhat complex parser to tie the URL to a handler. For example,
  one handler class has registered (webmail prefix, mailbox name, uid,
  part number) and is responsible for handling URLs that can be parsed
  as such.

  Each handler function instantiates a WebPage (not a subclass),
  adds some PageComponents to it, and returns that WebPage.

  A WebPage has a list of PageComponents, each of which must be able
  to represent itself, and the WebPage glues them together. Each
  PageComponent has a set of required PageFrontMatter objects, and the
  WebPage makes a union set and adds the necessary front matter.

  A PageComponent may also need to have some PageBlock, but I don't
  know whether we need that.

  So, to generate a web page, the HTTP class picks the URL apart (a
  difficult job) and matches it to a handler. The handler creates a
  WebPage and some objects of various PageComponent subclasses,
  e.g. HtmlMessageRenderer, HtmlMailboxView, whatever. The WebPage
  waits until each of the PageComponent (subclass) objects is ready to
  render itself, then looks at each component's declared front matter,
  then emits:

    - <!doctype> etc
    - front matter (e.g. code to pull in style sheets of javascripts)
      in the head tag
    - body tag and a little more to start
    - each page component
    - </body></html>

  This is good.

  PageBlock would be necessary in case some components cannot be
  directly below <body>...</body>.


Release cycle

  Five weeks, t-35 to t (a Monday).

  t-38: we decide on a feature list for the release.

  t-14: Whatever hasn't been started is dropped, whatever cannot be
  completed before t-7 is laid aside for the next release.

  t-7: Fork the release and remove any code that needs to be removed.

  t-4: Roll the tarball and do the release chores.

  t-3: See t-38 above.

  t-0: A crontab does what it needs to do.


The value of features

  Archiveopteryx provides online archiving. We want the features we
  add to improve one or more of these:
  - adding mail to the archive
  - accessing the archive
  - managing the archive

  For nontechnical reasons I add a fourth goal:
  - making current users happy

  Each new feature should help in some way; the new features that help
  the most are the ones we need most (in the long term - in the short
  term we also need to help existing users).


aoximport doesn't setInternalDate


make clean doesn't work (falls over deleting doc/man)


Undefined codepoints

  When a codec encounters an undefined codepoint, it should substitute
  U+FFFE (or FFFD/FFFF?) and continue parsing after setting a flag that
  later allows parseBodypart() to upgrade (or is that "downgrade"?) the
  entire message to UTF-8 for subsequent retrieval.

  This is done as a special case for GB2312/ISO-2022-JP right now.


Better caching.

  FieldNameCache etc. can use less memory by reading all field and
  flag names into RAM at startup. That way, the memory used won't be
  scattered across many blocks.


Port 587

  Half done. More. Outstanding work: add a smarthost variable, send
  mail from the deliveries/messages tables to the smarthost.

  Later, when we parse SMTP properly, we'll want to add/replace a
  Sender field if the authenticating user is not the address in From.


RFC 2852

  Easy to do once we have port 587; we need to set the end column
  right, that's about it.


FUTUREDELIVERY

  The draft has passed IESG evaluation. The last AD promised to clear
  his DISCUSS soon, and the Greg Vaudreuil expects no substantive
  changes from the draft to the RFC.

  Our code pretty much supports this, we just need to set the start
  column.


Message tracking

  RFCs 3885-8 specify ways to track messages that have been sent. We
  can implement that fairly easily.

  If we route outgoing mail via a smarthost, that smarthost has to
  support MTRK in order for tracking to work well.

  We can track mail provided that at least one of these is true:

  - we deliver directly to the end server (looking at received fields
    for mail from the same address can help ascertain that the best mx
    really is that)

  - we deliver via an MTRK-capable server

  - we deliver into our own database

  Sounds likely to be true maybe 80-90% of the time.

  If none are true, we can at least say, easily, where we delivered,
  when, and why.

  We could implement the tracking protocol (and I'd write a query blah
  in mailchen), and also provide a query interface via the web.


aox reinject

  Said command would search for unparsable messages in the DB, try
  each to see whether it can be parsed by the current version, and if
  so, inject the message in the relevant mailbox and delete the
  "cannot parse" message. While it does so, reinject should emit lots
  of progress information. Lots.

  Some problems there - what if the correct message would be sieved
  differently? do we have all the information we need, e.g.
  internaldate? how can we search for these bodyparts in the first
  place?


Bounces and DSNs

  Mail is currently fairly reliable. There is one big exception:
  Bounces aren't 100% parsable. But generally, if you work hard, you
  can know whether a message was delivered or not, and mostly they are
  delivered.

  So we benefit from converting the most common nonstandard bounces to
  DSNs, and then treat them as DSNs.

  For nonstandard bounces (like those of qmail) we identify the
  message by trying hard, do some hacky parsing, use the bounce
  (excluding trailing message) as first part of the DSN multipart,
  cook up a new DSN report based on the parsing, and save
  text/822-headers as a third part.

  Then, searches that tie bounces together with messages sent work
  even better.

  (Another trick we can/should use is to see whether the host we
  deliver to seems to be the final destination based on earlier
  (answered) messages.)


Memory use for common operations

  Some use _vastly_ too much memory. I saw a single IMAP FETCH for a
  mere 4200 messages use 173MB yesterday. (Later note: This should be
  gone, gone, gone, but it would still be good to check that these
  problems don't reappear, reappear, reappear.)

  The most elegant way to solve that would be to supervise memory
  usage for a known sequence. Inject these ten thousand messages,
  check memory use (via a hack), connect to the imap port run this and
  that, check again, connect to the imap port run this and that, check
  again, connect to the imap port run this and that, check
  again... just a bunch of checks. Ignore output.


Deleting mailbox has unclear semantics now

  At present, we don't allow a mailbox to be deleted until all
  undeletable messages from that mailbox have been sent to the great
  mailbox in the sky.

  We might want to change that, but what then? What if someone wants
  to rename a new mailbox to the name that used to be taken by this
  mailbox? Or creates ditto? What should happen to views onto this
  mailbox?


COPY is slow

  Inject 11k messages, copy with thunderbird, watch why it fails.

  Or better: Just fix the code. There are far too many inserts and
  updates. Two possible approaches.

  1. Identify UID ranges and use seven inserts per UID range.

     This should grow much slower than the size of the copy, since a
     large copy should generally contain just a few UID ranges. But
     the worst case is just as bad as before.

  2. Use exactly seven inserts and do the UID range work using
     CASE/WHEN/+.

     If it's exactly a single range, the target uid is the source uid
     plus some x we can find. If there are several, CASE/WHEN can be
     used to select the right x.

  Not sure which is best. Of course the latter has the "advantage" of
  generating huge SQL statements.

  I implemented approach 1 for now, and it gave me a very large speed
  improvement - 350 copies/second where it used to be 12-25, so a
  speedup of 1400-2900%.


MULTIAPPEND

  Stupid thing. Clients and servers using pipelining can do the same
  thing.

  But there it is, and change 52791 shows that if the injector learns
  to inject many addresses at at time, multiappend can be used to
  inject lots of messages quickly.

  aoximport can do it even better, of course.


imapd/handlers/acl.cpp

  Different tasks, some shared code, same file. Separate this out into
  different classes inheriting something. Then add the right sort of
  logging statement to the end of parse().


Opera often can't expunge

  Trace it once or twice, guess what's wrong.


ocd needs work (mike@waspfactory.org)

  1. The code (along with user/mailbox) needs cleaning up.
  2. Should synchronise field names etc.

  Note that we can drop ocd in the non-cluster case starting with
  1.07. Simply not start it.


Don't duplicate the contents of address_fields in header_fields.

  The Injector should avoid inserting address fields into header_fields,
  and the HeaderFetcher should assemble addresses from address_fields.


AddressCache and FieldNameCache are utter crocks, and must die.


Consider RFC2231:

  2231 says: IMAP4 [RFC-2060] servers SHOULD decode parameter value
  continuations when generating the BODY and BODYSTRUCTURE fetch
  attributes.

  Hopefully we don't need to care about this at all.

  Arnt's opinion: We're better off doing that at parse time. There's
  also some outlook breakage to support - it uses 2047 when it
  shouldn't.


ANNOTATE support

  Annotations are good. We want them. They're easy for us. By now the
  draft should be stable, so we can implement whenever we want to and
  have the time.

  Status:
  - schema changes: done
  - session state: done
  - SELECT/EXAMINE: done
  - FETCH: written, not tested, probably broken
  - STORE: done, currently broken
  - COPY: done (untested for lack of other support)
  - APPEND: can call code currently in STORE
  - SEARCH: done
  - SORT


METADATA

  Ditto. Separate point so that we can do one without the other.


Autoresponder

  We'll need one, nicely programmable, connected to our sieve.

  I was reminded of this by Google's wording:

  Thank you for writing to Google. This automated response is just to
  let you know that we've received your email, and you'll hear from us
  soon.

  Thank you for using Google.

  Regards,
  The Google Team


Message arrival tag

  Once annotate is done, we want a tag, ie. a magic annotation which
  stays glued to the message wherever it goes, even after copy/move.

  We also want a way to store the original RFC822 format somewhere
  inside and/or outside the database, indexed by the arrival tag
  identifier. It's good if the tag is split, so we can have "x-y"
  where X is the CD/DVD number and Y is the file on the CD/DVD. Or
  something like that.


Message Retention Policy Framework

  A lot of sites will want explicit policies regarding what mail may
  not be deleted, what may be deleted, and what must be deleted. We
  can support that well.


C/R

  C/R sucks. But it has its uses, so we can benefit from implementing
  it somehow. Here are some classes of messages we may want to treat
  specially:

  - replies to own mail
  - messages in languages not understood by the user
  - mail from previously unknown addresses
  - mail from freemail providers
  - vacation responses from unknowns
  - messages likely, but not certain to be out-of-office-autoreply
  - dkim/mass-signed messages (if veridified)

  The questions are: How can we ensure that we almost never challenge
  real mail, while simultaneously challenging most/all messages that
  don't come from valid senders? How can we provide suitable
  configuration?


We should figure out some way to not store plaintext passwords.

  In practice, the only way is to subcontract the dirty work to an
  LDAP server. We act as a MITM while doing SASL authentication and
  that's all.


Using rrdtool

  What could we want to graph with rrdtool? Lots.

  - RAM used
  - CPU seconds used
  - database size
  - messages in the db
  - average response time
  - 95th percentile response time
  - messages injected
  - messages per user
  - message size per user
  - logged-in users
  - concurrent connections (per protocol)
  - logins (per protocol)
  - login failures (per protocol)

  More?

  The natural way to do it would be to have archiveopteryx collect
  some/most variables in RAM, and provide a query via aox+ocd. some
  things (messages/message size per user at least) are better done as
  a db query from aox directly.

  'aox show statistics'?


SASL NTLM authentication

  It may be odd and undocumented, and it may not be as strong as
  DIGEST-MD5, but it's implemented in Certain Clients ;)

  http://www.innovation.ch/java/ntlm.html seems to be a reasonable
  description. Cyrus also implements it.


SASL LOGIN authentication

  Implemented in Certain Clients ;)

  There's a draft by Ken Murchison.


httpd segfaults when you click on a message (Harri).


Make the httpd do archive pages

  Shouldn't we be most of the way there? Need partial result pages and
  real searching, though.

  Notify denis@startsiden.no when external testers might want to look
  at it.


archives.oryx.com

  Mostly need httpd archiving.


Miscellaneous cleanups:

  * Get rid of Blah::setup wherever possible
  * Avoid unnecessary header file inclusion
  * Enable the #ifdef'ed out tests
  * Do the "uint characters[256]" thing to simplify parsing.


DELETE of mailboxes in inappropriately qualified (security problem)

  At present, the user always needs to have all three rights, and
  there's a race condition against append/copy. It would be better to
  grab the uidnext lock and do more fine-grained checking:

  1. Require DeleteMessages unless all messages have \deleted.

  2. Require Expunge if there are any messages at all.

  The race condition means it's possible to append to a mailbox while
  it's being deleted, and the message will reappear if the mailbox is
  later recreated. We could solve the latter by emptying the mailbox
  at recreate time.


Split the folder view into pages.

  The injector needs to do threading to make the paging possible.


A failing parse message should invalidate the prepared statement cache.


We need mUTF-7 support.


Write better field wrapping code

  HeaderField::wrap is terribly hackish right now. Besides, ::unwrap()
  should become the higher-level parser's job.


We should be able to use a read-only local database mirror.

  That way, we can play nicely with most replication systems.

  The way to do it: add a new db-mirror setting pointing to a
  read-only database mirror. all queries that update are sent to
  db-address, all selects are sent to db-mirror. db-mirror defaults to
  db-address.


canonical and deliver need severe cleaning up.

  In fact, maybe deliver needs to die. aoximport takes over most of
  the job, and the rest is often best not done. We don't want to have
  fetchmail-like bugs.


Read the GiST papers and look at tsearch2 again.


migrator should work without indices

  If the database is otherwise idle, the migrator could disable indices
  and perhaps transactions, and go much faster.


Add Maildir support to the migrator.

  Currently works, with two exceptions: Submaildirs don't work, and
  courier's extended flags don't work.


We should test multipart/signed and multipart/encrypted support.

  We must add a selection of RFC 1847 messages to canonical, and make
  sure they survive the round trip. No doubt there will be bugs.


Something confuses Address::uname() and Address::name()

  As a result, we send unlabelled 8-bit content in display-names if
  the name cannot be expressed in either 8859-1, 8859-2 or koi8-r.

  I think the underlying reason is that we're not using UString, so
  the compiler's type checking does nothing for us.

  This is easy to demonstrate with 22 right now, but it won't be
  shortly - I'll make a separate change which accidentally obliterates
  the difference.


We should store bodyparts.text for PDF/DOC.

  We need non-GPLed code to convert PDF and DOC to plaintext. We already
  use the code from Mailchen to convert HTML.


CAcert instead of self-signed certificate?

  www.cacert.org offers free certificates and seems to be an
  up-and-coming thing.  In a few months, we may want to add 'obtain
  valid cert from cacert'.

  Btw, cacert.org is a very nice place to get praise and a link from. High
  nerd factor. If we have the first really-easy-to-use interface to
  get cacert interfaces into a program, they'll do that, no doubt.


Switch to using named constraints everywhere.


Default c-t-e of PGP signatures

  Right now we give them binary. q-p or 7bit would be better, I think.

  What other application/* types are really text?

  From a conversation the other day: we could avoid base64 encoding an
  entity whose content-type is not text if it contains only printable
  ASCII. I don't know if it's worth doing, though.

  The problem with doing that is that it treats sequences of CR LF, CR
  and LF as equivalent. An application/foobar object that happens to
  contain only CR, LF and printable ASCII can be broken.


The IMAP SORT extension seems really easy

  Squirrelmail wants it. Strongly. And it's not terribly difficult to
  implement, to put it mildly.

  Interacts with ANNOTATE.


Something like soft-bounce might just be useful

  enabled: smtp/lmtp always give 4xx errors. disabled: either 4xx or
  5xx depending on the type of error.


recognising spam

  The good spam filters now all seem to require local training with
  both spam and nonspam corpora. We can do clever stuff... sometimes.

  Instead of filtering at delivery, we can filter when a message
  becomes \recent. When we increase first_recent, we hand each new
  message to the categoriser, and set $Spam or $Nonspam based on its
  answer.

  This lets the categoriser use all the information that's available
  right up to the moment the user looks at his mail.

  We can also build corpora for training easily. All messages to which
  users have replied are nonspam, replies to messages from local users
  are nonspam, messages in certain folders are spam, messages with a
  certain flag are spam.

  We can connect to a local server to ask whether a message is spam.
  They seem to work that way, but with n different protocols.


Replace Mailbox::isHome with something correct.

  It should look for a mailbox whose owner is different from its
  parent's owner.


TLS client support (smtp, postgresql)


We MUST support HTTPS for the webmail interface.


"Writing Secure Code"

  We have a page about security, /mailstore/security.html, and a
  section of the mailstore.7 man page mentions it too.

  We need to look at ISBN 0735617228 and improve security.html with
  points from it. It could also be that we'll improve the code itself.


udoc stuff:

  1. Support a single level of nested classes. (What file names to use
     for output?)
  2. Support enum annotation.
  3. Suppress empty <p>, duplicate anchor names in output.


Udoc web pages chores

  Add "Related Pages" etc. Clarify where background.html
  fits. usage.html is an orphan now; should it become a manpage?


Play with PITR and write /ams/pitr.html


Update doc/recorder.man

  Must decide whether to use .SS or .IP, etc.


Document IPC structure

  Some man page, or some web page, or both, should say who's
  connecting to who and why.


Add a web page about the charset encoding.

  It's a novel and good algorithm, so we can make a good page about
  it. We also can link to data sources there.

  The documentation for Codec::byString() should mention that page's
  URL.


Make a web page about our licensing

  Not sure what to say there. the purpose of the page would be to
  direct people to one of the two others, really. and to be linked to
  from the home page.


The "Database" link on home page

  Where should it go? People might click it wondering why to use a
  database instead of flat files and wanting to know what we do with
  databases.


Interop pages

  A variety needed.


Protocols supported

  A list detailing what our general idea is (internet standard,
  interoperability, utility) and linking to each actual protocol page.

  The URL for this is difficult.


Search ourselves, not via google

  Or maybe farm that out, get google to search with an approximation
  of our design. http://www.google.com/faq_freewebsearch.html may be
  interesting.


Fix shutdown

  There's no practical way to shutdown using ocd/ocadmin. Perhaps this
  is another aspect of the problem above.


Logging to syslog

  logfile=syslog:local2 could mean "log to syslog with the local2
  facility". that's ugly syntax. parsing and blah.

  if we implement this, the logd HUP handler can switch to syslog if
  it can't reopen the logfile.


aox restart and aox start don't check all they could

  Improvements:

  1. aox restart and aox start should bind to the IP addresses specified
     by all the relevant servers (but not the ports) and try to
     connect to the ports.

  2. aox restart can issue 'aox start' when the last established
     connection dies. currently it calls sleep(1).

  3. aox start can expect all the connects to fail. if a connect
     succeeds, someone else is using that port, so our server won't.

  4. Both of them should expect all the binds to succeed. if not,
     mailstore.conf contains a bad address.


Make User::create/remove work like Mailbox::create/remove. (AMS)


Make sure UIDs never exceed 2**31 (and break getInt).


Rendering webmail HTML is presumably good, but...

  Knowledge is better than presumption.

  Webmail services have a lot of known holes. Cross site scripting and
  suchlike. We can add known sploits/demos to our rendering tests, and
  check that we're not vulnerable.

  Two I saw today: http://www.sec-consult.com/232.html and
  http://www.sec-consult.com/233.html


When TlsServer dies, imaps (993) must go away

  It doesn't at the moment. Anything else?


Faster mapping from unicode to 8-bit encodings

  At the moment, we use a while loop to find the right codepoint in an
  array[256]. Mapping U+00EF to latin-1 requires looping from 0 to
  0xEF, checking those 239 entries.

  We could use a DAG of partial mappings to make it faster. Much
  faster. Mapping U+20AC to 8895-15 would require just one lookup: In
  the first partial table for 8859-15. Mapping U+0065 to 8859-15 would
  require three: In the first (U+20AC, one entry long), in the
  fallback (U+00A0, 96 entries long) and in the last (U+0000, 160
  entries long).

  Effectively, 8859-15 would be a first table of exceptions and then
  fall back to 8859-1.

  The tables could be built automatically, compiled in, and would be
  tested by our existing apparatus.


Multipart/signed automatic processing

  We could check signatures automatically on delivery, and reject bad
  signed messages.

  The big benefit is that some forgeries are rejected, even though the
  reader and the reading MUA doesn't do anything different.

  The disadvantage is that we (probably?) can't verify all signatures,
  which gives a false sense of security for the undetactable forgeries.

  In case of PKCS7, it's possible to self-sign. Those we cannot
  check. In that case we remove the signature entirely from the MIME
  structure, so it doesn't look checked to the end-user.

  PGP cannot be checked, except it sort of can. We can have a small
  default keyring including the heise.de CA key and so on, and treat
  that as root CAs, using the keyservers to dig up intermediate keys.


PGP automatic processing

  Apparently there are five different PGP wrapping formats. We could
  detect four and transform them to the proper MIME format.


imap/hackedsize#2 doesn't work.

  - The Received field added by smtpd changes.
  - The x-obliterate breaks ocd, so the select response is weird.


LDAP server/address book

  Joins rock. We can join ALL OUR TABLES and get INCREDIBLE
  FLEXIBILITY AND POWER.

  LDAP AB can provide several address books based on the archive:

   - all addresses visible anywhere
   - all addresses in your mailboxes
   - all addresses in mailboxes to which your groups have access
     (the join for this is a little hard)
   - all v-card bodyparts
   - all v-cards in your mailboxes
   - all v-cards in mailboxes to which your groups have access
     (I suppose one might even say "breathtakingly complex join")

  Admins can enable/disable each of those depending on site policy.

  http://www.onlamp.com/lpt/a/3310 may be helpful wrt i14y testing.
  thunderbird should do what it says.

  http://www.dice.inf.ed.ac.uk/groups/infrastructure/directory/support/usingldap.html
  talks about some clients. I suggest that working with those clients
  is all we aim for.


Groups and ACL

  We don't need groups as of now, but they do have their handy-dandy
  aspects. If we add groups, see the LDAP AB item.


Get rid of FORTRAN typing

  Instead of using UString, we sometimes use String and "assume it to
  be UTF-8", except that sometimes we forget to assume that. Fix that.
  Also unfuck HeaderField::encode{Word,Phrase} in a different way -
  they use different tests for whether 2047 encoding is necessary, and
  I don't think either is right.


VIEW CREATE seems unpredictable

  Occasionally, the \view flag doesn't appear quickly on the created
  mailbox. This may be due to OCClient - I recent saw a mailbox update
  its UIDs very lage (long after append had reported the new UID to
  the IMAP client).


Plugins

  It's not given that we want to accept all mail. If we don't, who
  makes the decision? A sieve script may, and refuse/reject mail it
  does not like. And a little bit of pluginnery may. I think we'd do
  well to support the postfix plugin protocol, so all postfix policy
  servers can work with aox. (All? Or just half? Doesn't postfix have
  two types of policy plugins?)

  We may even support site-wide and group-wide sieve scripts and
  permit a sieve script to invoke the plugin. A sieve statement like
  this?

     UsePolicyServer localhost 10023 ;


BURL

  If the message is multipart and the boundary occurs in a part, that
  part needs encoding. Or else switch to a different body.


RFC 4616

  Does this need any changes to our code? No? -- Arnt

  I have reviewed RFC 4616, and the only relevant change is the SASLprep
  stuff (RFCs 3454/4013). That needs discussion, but it's a far-reaching
  change beyond just PLAIN. -- AMS


tlsproxy needs better diagnostics

  - Primer tried to use it with an OpenSSL key, and it exited silently.
    Now it's not silent, but it's not helpful either.
  - We should document /somewhere/ how to use pemtrans to produce keys
    for aox ("Archiveopteryx private key" and "secret" are completely
    mysterious right now; and perhaps they should be configurable? I
    can't imagine anyone wanting to configure them, though).
  - pemtrans's usage message should be more helpful (though the manpage
    does explain).
  - We should regenerate the automatic-key.p15 if we find that the
    existing key's CN doesn't match our current hostname.

  (Who is Primer?)


NOTIFY implementation

  Implement NOTIFY after revision -04 of the draft.

  We can also autodetect client smarts: If we haven't sent any
  unsolicited EXISTS, we just send one, and if the client reacts to
  that, we can send more. Sounds difficult to explain but I suspect
  the implementation will be less than five lines of code over and
  above NOTIFY.


Todo list: AMS

  - Upgrade to cryptlib 3.3.
    The problems mentioned earlier were found to affect only testlib's
    threading, and were thus not relevant to us. I sent a bug report to
    Peter, and am now updating our in-source tree.
  - Figure out why tlsproxy segfaults on Thomas's box.
  - Go through ANNOTATE and make sure we have and test everything.
  - Fix imap/view and the recent problems.
  - Figure out the Injector upper bound on Injector speed.
  - Log single-row query values?
  - Use writev in Buffer::write.
  - canonical problems.
  - Poke hdp and jd@commandprompt.
  - Revive dbtest
  - Investigate Scalix/Zimbra/TeamXchange.
  - Make sure LIKE parameters in selector.cpp (whereAddressField in
    particular) are [\%_]-escaped as in q().
  - Make Schema::check independent of upgrade so that we can revoke
    update on mailstore from aox.
  - Restart Postgres while we're running, and see what happens. We
    should be able to cope with that gracefully, but we don't.
  - Add some test cases and so on so problems aren't only recorded in
    an "owned by AMS" list.
  - We seem to be mangling Tom Simnett's PGP-signed email. Get him to
    send something to ams@toroid.org and make a canonical test case.
  - Use Ethereal to snoop on Thunderbird talking to OpenLDAP to query
    an address book.
  - aox start should say "already running" if that's true.
  - DIGEST-MD5 reauth doesn't work for Dave.
  - Alexey suggest that we resend CAPABILITY after LOGIN.
  - Date::valid doesn't reject February 29th 2007.
