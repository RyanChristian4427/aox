2.04: 2007-10-22

  SIEVE subaddress (RFC 3598, draft-ietf-sieve-rfc3598bis).

    Done, but more testing needed.

  SIEVE date/index (draft-freed-sieve-date-index).
  Needs relational tests (RFC 3431/draft-ietf-sieve-3431bis).

  SIEVE vacation (draft-ietf-sieve-vacation).

  httpd: webmail, archives, search results.

  Proper case insensitivity for mailbox and user names.

  Bugs:

  - OS X compiles on PPC break because cryptlib/Jamfile statically
    defines -DDATA_LITTLEENDIAN.

  - db-address=localhost doesn't work (see note).

  - SMTP message-copy doesn't work any more (fixed)

  - Martin Rode's umlauts are broken (example/test needed)

  Schedule:

    2007-09-14: decide on feature list
    2007-10-08: drop things that can't be finished
    2007-10-15: fork and remove unusable code
    2007-10-18: roll, release chores
    2007-10-19: features for next release
    2007-10-22: release

  Arnt is responsive.


2.05: 2007-12-03

  Last release before the new year.

  Abhijit is responsive.


2.06: 2008-01-14

  Six weeks after 2.05, I think.

  Arnt is away from 2007-12-20 to 2008-01-03.


2.07: 2008-02-18

  Five weeks after 2.06.


Release cycle

  Five weeks, t-35 to t (a Monday).

  t-38: we decide on a feature list for the release.

  t-14: Whatever hasn't been started is dropped, whatever cannot be
  completed before t-7 is laid aside for the next release. Write the
  announcement text.

  t-7: Fork the release and remove any code that needs to be removed.

  t-4: Roll the tarball and do the release chores.

  t-3: See t-38 above.

  t-0: A crontab does what it needs to do.


The value of features

  Archiveopteryx provides online archiving. We want the features we
  add to improve one or more of these:
  - adding mail to the archive
  - accessing the archive
  - managing the archive

  For nontechnical reasons I add a fourth goal:
  - making current users happy

  Each new feature should help in some way; the new features that help
  the most are the ones we need most (in the long term - in the short
  term we also need to help existing users).


The next eight months

  - Message retention
      User interface
      Message identification
      Logging changes to the message
  - aoximport improvements
  - Full text search
  - More documentation
      aox operations guide
      best practice papers
  - Better documentation
  - VIEW improvements
      INTHREAD
      multi-mailbox searches
      miscellaneous
  - Account management
      ACL management
      VIEW management
  - Recording the fate of outgoing mail
  - Proper full-text searching
  - Better exploratory search
  - Useful webmail
  - Address search
      Web UI
      IMAP X-extension
      Exporting to addressbooks
  - Monitoring
      Graphing


Items for web site

  In addition to stuff in the operations guide:

  - List/description of IMAP/POP/SMTP extensions
  - RFC pages
  - man pages (old ones too)
  - Source documentation
  - Best practices
  - FAQ
  - Version-specific pages
  - Download-specific pages
  - Client-specific pages


Installer doesn't take steps to ensure that the installation is usable

  It could do at least two things:

  Run all the same checks on the new installation as 'aox check' and
  archiveopteryx at startup.

  Try to connect to all the server addresses and if anything's
  listening anywhere, mention it on stdout.

  In addition to this, the installer does the wrong thing right now if
  it creates the database users and then fails to run psql to load the
  schema. It exits with an error, which means the randomly-generated
  passwords are lost, because the configuration file is not written.


Various TODO items from earlier releases.

  Message retention policy

  - Soft-quota/archival stuff too?
  - Message arrival tag (for archiving)

  aoximport could be much faster (disable indices, commit several
  thousand messages at a time in one big transaction), but it's a fair
  bit of work (unless aoximport has a private Injector or Injector can
  take a list of Message objets)

  Autoresponder

  Miscellaneous:

  - Database replication support (local mirror)
  - Split the injector transaction into fast and slow parts(?)

  SORT (/THREAD?)

  Basic administration using the httpd

  Indexing for DOC bodyparts

  aox backup/restore (or similarly helpful procedure)

  Full-text search


Not enough name resolution: db-address=localhost doesn't work.

  The name is resolved at startup, but nothing ever calls the resolver
  to retrieve the value. One way to fix this would be to make Endpoint
  itself accept names and resolve them. The downside is: what if there
  are multiple addresses, e.g. 127.0.0.1 and ::1?

  There are three cases, perhaps four:

  - Our own servers, where it's clear what should happen, and
    Listener::create() does the right thing.
  - Outgoing connections where we need a connection to any address.
  - Outgoing connections where we need a connection to each address.
  - Outgoing connections where >1 addresses is not meaningful, not
    tested or otherwise undesirable.

  Each user of Endpoint needs to handle this. That's Listener,
  Database, LogClient and OcClient, right? (SpoolManager/SmtpClient need
  to resolve an Endpoint too. bin/aox needs to be able to connect to the
  same things the Listener decides to listen to.)


Cleartext passwords

  We help migrating away from cleartext/plaintext passwords:

  1. We also store SCRAM and similar secrets in the DB (secrets which
     aren't password equivalents)
  2. We extend the users table with two new columns, 'last time
     cleartext was needed' and 'number of successful authentications
     without cleartext password usage since cleartext'.
  3. If a client uses SCRAM, we increment the counter.
  4. If a client uses CRAM or PLAIN, we reset counter and set the time
     to today.
  5. We provide some helping code to delete passwords for users with a
     high count and a long-ago time.
  6. We add documentation saying that if you disable auth-this and
     auth-that, you can disable store-plaintext-passwords.
  7. We add configuration/db sanity checks for ditto.


Login failures

  We want to log those a little more, and show them on the
  webmail/admin pages.

  Specifically, if user x cannot log in, what mechanism was used, what
  was the problem, etc?


aox check schema

  This command would check several things.

  a) that dbuser has the needed rights
  b) that all the right tables are there, and all the right columns,
     with the right types, and no unexpected constraints
  c) that all the right indexes are there
  d) that dbowner owns everything

  As a bonus, perhaps it could list some unexpected/unknown deviations:
  e) locally added tables
  f) locally added columns
  g) locally added indices
  h) missing constraints


Database schema range

  Poeple occasionally need to access the db with an old version of
  mailstore. I suggest that we:

  a) add a 'writable_from' column specifying the oldest version that
     can write to the database.
  b) add a 'readable_from' column specifying the oldest version that
     can read the database

  aox upgrade schema would update writable_from to the oldest schema
  version for which a writer would do the right job. This would often
  change when a table changes, but not when a table is added.

  readable_from would be the oldest revision that can read the database.

  When the server starts up, it would check:

  - am I >writable_from? If so, mailboxes can be read-write
  - else, am I >readadble_from? If so, startup can proceed, but all
    mailboxes are read-only. lmtp, smtp and smtp-submit do not start.
  - else, quit.

  And in order to handle database updates, I suggest another table,
  'features', with a single string column. When aox update database
  fixes something, it inserts a row into features. A modern database
  would have two rows in this table, 'numbered address fields' and 'no
  nulls in bodyparts'.


Sieve

  Alexey suggests the following extensions (in the following order):
  Vacation, reject, imapflags, subaddress.

  Arnt wants the date tests, in order to use office-hours
  vs. after-hours work.


Better caching.

  FieldNameCache etc. can use less memory by reading all field and
  flag names into RAM at startup. That way, the memory used won't be
  scattered across many blocks.


RFCs 2852 and 4865

  Easy to do once we have port 587; we need to set the start and end
  columns right, that's about it.


Message tracking

  RFCs 3885-8 specify ways to track messages that have been sent. We
  can implement that fairly easily.

  If we route outgoing mail via a smarthost, that smarthost has to
  support MTRK in order for tracking to work well.

  We can track mail provided that at least one of these is true:

  - we deliver directly to the end server (looking at received fields
    for mail from the same address can help ascertain that the best mx
    really is that)

  - we deliver via an MTRK-capable server

  - we deliver into our own database

  Sounds likely to be true maybe 80-90% of the time.

  If none are true, we can at least say, easily, where we delivered,
  when, and why.

  We could implement the tracking protocol (and I'd write a query blah
  in mailchen), and also provide a query interface via the web.


aox reparse

  Maximilian Mehnert wants to save the failing messages and their
  current error reports in a format suitable for bug reports.


Thread-Index from Exchange

  We could look at Thread-Index and reconstruct In-Reply-To in order to
  properly thread messages we a) aoximport from Exchange, or b) receive
  during a conversation with an Exchange user.


Bounces and DSNs

  Mail is currently fairly reliable. There is one big exception:
  Bounces aren't 100% parsable. But generally, if you work hard, you
  can know whether a message was delivered or not, and mostly they are
  delivered.

  So we benefit from converting the most common nonstandard bounces to
  DSNs, and then treat them as DSNs.

  For nonstandard bounces (like those of qmail) we identify the
  message by trying hard, do some hacky parsing, use the bounce
  (excluding trailing message) as first part of the DSN multipart,
  cook up a new DSN report based on the parsing, and save
  text/822-headers as a third part.

  Then, searches that tie bounces together with messages sent work
  even better.

  (Another trick we can/should use is to see whether the host we
  deliver to seems to be the final destination based on earlier
  (answered) messages.)


Memory use for common operations

  Some use _vastly_ too much memory. I saw a single IMAP FETCH for a
  mere 4200 messages use 173MB yesterday. (Later note: This should be
  gone, gone, gone, but it would still be good to check that these
  problems don't reappear, reappear, reappear.)

  The most elegant way to solve that would be to supervise memory
  usage for a known sequence. Inject these ten thousand messages,
  check memory use (via a hack), connect to the imap port run this and
  that, check again, connect to the imap port run this and that, check
  again, connect to the imap port run this and that, check
  again... just a bunch of checks. Ignore output.


Deleting mailbox has unclear semantics now

  At present, we don't allow a mailbox to be deleted until all
  undeletable messages from that mailbox have been sent to the great
  mailbox in the sky.

  We might want to change that, but what then? What if someone wants
  to rename a new mailbox to the name that used to be taken by this
  mailbox? Or creates ditto? What should happen to views onto this
  mailbox?


3.0 changes

  - Don't announce digest-md5 by default.


MULTIAPPEND

  Stupid thing. Clients and servers using pipelining can do the same
  thing.

  But there it is, and change 52791 shows that if the injector learns
  to inject many addresses at at time, multiappend can be used to
  inject lots of messages quickly.

  aoximport can do it even better, of course.


imapd/handlers/acl.cpp

  Different tasks, some shared code, same file. Separate this out into
  different classes inheriting something. Then add the right sort of
  logging statement to the end of parse().


Opera often can't expunge

  Trace it once or twice, guess what's wrong.


ocd needs work (mike@waspfactory.org)

  1. The code (along with user/mailbox) needs cleaning up.
  2. Should synchronise field names etc.


AddressCache and FieldNameCache are utter crocks, and must die.


aox/conf/*

  Possible category pages, each listing all variables that influence
  blah

  conf/encryption
  conf/authentication
  conf/webmail
  conf/submission
  conf/imap
  conf/database

  More?


aox/conf/tls-certificate

  Those variables are not well described. We need a bit more.

  Also, -secret is probably misnamed, we use -password for other
  cases. I expect that's why aox show cf tls-certificate-secret yields
  while e.g. aox show cf db-password does not.


METADATA

  Needed for lemonade, as easy as annotate.


Autoresponder

  We'll need one, nicely programmable, connected to our sieve.

  I was reminded of this by Google's wording:

  Thank you for writing to Google. This automated response is just to
  let you know that we've received your email, and you'll hear from us
  soon.

  Thank you for using Google.

  Regards,
  The Google Team


Message arrival tag

  Once annotate is done, we want a tag, ie. a magic annotation which
  stays glued to the message wherever it goes, even after copy/move.

  We also want a way to store the original RFC822 format somewhere
  inside and/or outside the database, indexed by the arrival tag
  identifier. It's good if the tag is split, so we can have "x-y"
  where X is the CD/DVD number and Y is the file on the CD/DVD. Or
  something like that.


Message Retention Policy Framework

  A lot of sites will want explicit policies regarding what mail may
  not be deleted, what may be deleted, and what must be deleted. We
  can support that well.


C/R

  C/R sucks. But it has its uses, so we can benefit from implementing
  it somehow. Here are some classes of messages we may want to treat
  specially:

  - replies to own mail
  - messages in languages not understood by the user
  - mail from previously unknown addresses
  - mail from freemail providers
  - vacation responses from unknowns
  - messages likely, but not certain to be out-of-office-autoreply
  - dkim/mass-signed messages (if veridified)

  The questions are: How can we ensure that we almost never challenge
  real mail, while simultaneously challenging most/all messages that
  don't come from valid senders? How can we provide suitable
  configuration?


Using rrdtool

  What could we want to graph with rrdtool? Lots.

  - RAM used
  - CPU seconds used
  - database size
  - messages in the db
  - average response time
  - 95th percentile response time
  - messages injected
  - messages per user
  - message size per user
  - logged-in users
  - concurrent connections (per protocol)
  - logins (per protocol)
  - login failures (per protocol)
  - queries executed per second
  - average query execution time
  - average query queue size

  More?

  The natural way to do it would be to have archiveopteryx collect
  some/most variables in RAM, and provide a query via aox+ocd. some
  things (messages/message size per user at least) are better done as
  a db query from aox directly.

  'aox show statistics'?

  http://jwatt.org/svg/authoring/ is interesting for generating graphs
  via the web interface.


SASL NTLM authentication

  It may be odd and undocumented, and it may not be as strong as
  DIGEST-MD5, but it's implemented in Certain Clients ;)

  http://www.innovation.ch/java/ntlm.html seems to be a reasonable
  description. Cyrus also implements it.


Resolving the remaining parse problems

  Kalyani now has 652 messages with parse problems. The ones still not
  fixed:

  3 with conflicting c-t. All are text/html vs. text/plain, which we
  can resolve.

  80 have bad content-type fields, so the boundary cannot be read. I
  don't want to generalise from the ones I looked at, other than to
  note that they all are single-level, and we could infer the boundary
  by looking for boundary lines.

  6 have bad charset encoding. All six seem guessable. The workarounds
  for the encodings are also possible, but invoking the guesser seems
  like a better option.

  104 have syntax errors in From. No analysis yet.

  6 have bad mime-versions. We could drop the check (...hmm...)

  34 have bad reply-to fields. No analysis yet.

  33 have unhandled 8-bit in the subject.

  40 have various forms of syntax error in To. About half seem easily
  fixable.

  The last few were scattered.


DELETE of mailboxes in inappropriately qualified (security problem)

  At present, the user always needs to have all three rights, and
  there's a race condition against append/copy. It would be better to
  grab the uidnext lock and do more fine-grained checking:

  1. Require DeleteMessages unless all messages have \deleted.

  2. Require Expunge if there are any messages at all.

  The race condition means it's possible to append to a mailbox while
  it's being deleted, and the message will reappear if the mailbox is
  later recreated. We could solve the latter by emptying the mailbox
  at recreate time.


Split the folder view into pages.

  Need to decide on what a page is. "Most recent 25 threads" is a
  slippery concept when a new thread is created while reading mail.


Write better field wrapping code

  HeaderField::wrap is terribly hackish right now. Besides, ::unwrap()
  should become the higher-level parser's job.


We should be able to use a read-only local database mirror.

  That way, we can play nicely with most replication systems.

  The way to do it: add a new db-mirror setting pointing to a
  read-only database mirror. all queries that update are sent to
  db-address, all selects are sent to db-mirror. db-mirror defaults to
  db-address.


Add Maildir support to the migrator.

  Currently works, with two exceptions: Submaildirs don't work, and
  courier's extended flags don't work.


We should test multipart/signed and multipart/encrypted support.

  We must add a selection of RFC 1847 messages to canonical, and make
  sure they survive the round trip. No doubt there will be bugs.


Something confuses Address::uname() and Address::name()

  As a result, we send unlabelled 8-bit content in display-names if
  the name cannot be expressed in either 8859-1, 8859-2 or koi8-r.

  I think the underlying reason is that we're not using UString, so
  the compiler's type checking does nothing for us.

  This is easy to demonstrate with 22 right now, but it won't be
  shortly - I'll make a separate change which accidentally obliterates
  the difference.


We should store bodyparts.text for PDF/DOC.

  We need non-GPLed code to convert PDF and DOC to plaintext. We already
  use the code from Mailchen to convert HTML.


Switch to using named constraints everywhere.


Default c-t-e of PGP signatures

  Right now we give them binary. q-p or 7bit would be better, I think.

  What other application/* types are really text?

  From a conversation the other day: we could avoid base64 encoding an
  entity whose content-type is not text if it contains only printable
  ASCII. I don't know if it's worth doing, though.

  The problem with doing that is that it treats sequences of CR LF, CR
  and LF as equivalent. An application/foobar object that happens to
  contain only CR, LF and printable ASCII can be broken.


The IMAP SORT extension seems really easy

  Squirrelmail wants it. Strongly. And it's not terribly difficult to
  implement, to put it mildly.

  Interacts with ANNOTATE.

  As soon as this is done, it's possible to test the 'now' part of
  internaldate, by assuming that 'now' is chronologically later than
  any other date tested.


Something like soft-bounce might just be useful

  enabled: smtp/lmtp always give 4xx errors. disabled: either 4xx or
  5xx depending on the type of error.


recognising spam

  The good spam filters now all seem to require local training with
  both spam and nonspam corpora. We can do clever stuff... sometimes.

  Instead of filtering at delivery, we can filter when a message
  becomes \recent. When we increase first_recent, we hand each new
  message to the categoriser, and set $Spam or $Nonspam based on its
  answer.

  This lets the categoriser use all the information that's available
  right up to the moment the user looks at his mail.

  We can also build corpora for training easily. All messages to which
  users have replied are nonspam, replies to messages from local users
  are nonspam, messages in certain folders are spam, messages with a
  certain flag are spam.

  We can connect to a local server to ask whether a message is spam.
  They seem to work that way, but with n different protocols.


Replace Mailbox::isHome with something correct.

  It should look for a mailbox whose owner is different from its
  parent's owner.


TLS client support (smtp, postgresql)


"Writing Secure Code"

  We have a page about security, /mailstore/security.html, and a
  section of the mailstore.7 man page mentions it too.

  We need to look at ISBN 0735617228 and improve security.html with
  points from it. It could also be that we'll improve the code itself.


udoc stuff:

  1. Support a single level of nested classes. (What file names to use
     for output?)
  2. Support enum annotation.
  3. Suppress empty <p>, duplicate anchor names in output.


Udoc web pages chores

  Add "Related Pages" etc. Clarify where background.html
  fits. usage.html is an orphan now; should it become a manpage?


Play with PITR and write /ams/pitr.html


Document IPC structure

  Some man page, or some web page, or both, should say who's
  connecting to who and why.


Add a web page about the charset encoding.

  It's a novel and good algorithm, so we can make a good page about
  it. We also can link to data sources there.

  The documentation for Codec::byString() should mention that page's
  URL.


Make a web page about our licensing

  Not sure what to say there. the purpose of the page would be to
  direct people to one of the two others, really. and to be linked to
  from the home page.


The "Database" link on home page

  Where should it go? People might click it wondering why to use a
  database instead of flat files and wanting to know what we do with
  databases.


Interop pages

  A variety needed.


Protocols supported

  A list detailing what our general idea is (internet standard,
  interoperability, utility) and linking to each actual protocol page.

  The URL for this is difficult.


Search ourselves, not via google

  Or maybe farm that out, get google to search with an approximation
  of our design. http://www.google.com/faq_freewebsearch.html may be
  interesting.


Fix shutdown

  There's no practical way to shutdown using ocd/ocadmin. Perhaps this
  is another aspect of the problem above.


Logging to syslog

  logfile=syslog:local2 could mean "log to syslog with the local2
  facility". that's ugly syntax. parsing and blah.

  if we implement this, the logd HUP handler can switch to syslog if
  it can't reopen the logfile.


RFC 5032

  Desirable, but takes a little bit of doing in the selector.


Rendering webmail HTML is presumably good, but...

  Knowledge is better than presumption.

  Webmail services have a lot of known holes. Cross site scripting and
  suchlike. We can add known sploits/demos to our rendering tests, and
  check that we're not vulnerable.

  We have a potential security hole: A malevolent HTML bodypart is
  forwarded as is on the "download bodypart" page.


When TlsServer dies, imaps (993) must go away

  It doesn't at the moment. Anything else?


Faster mapping from unicode to 8-bit encodings

  At the moment, we use a while loop to find the right codepoint in an
  array[256]. Mapping U+00EF to latin-1 requires looping from 0 to
  0xEF, checking those 239 entries.

  We could use a DAG of partial mappings to make it faster. Much
  faster. Mapping U+20AC to 8895-15 would require just one lookup: In
  the first partial table for 8859-15. Mapping U+0065 to 8859-15 would
  require three: In the first (U+20AC, one entry long), in the
  fallback (U+00A0, 96 entries long) and in the last (U+0000, 160
  entries long).

  Effectively, 8859-15 would be a first table of exceptions and then
  fall back to 8859-1.

  The tables could be built automatically, compiled in, and would be
  tested by our existing apparatus.


Multipart/signed automatic processing

  We could check signatures automatically on delivery, and reject bad
  signed messages.

  The big benefit is that some forgeries are rejected, even though the
  reader and the reading MUA doesn't do anything different.

  The disadvantage is that we (probably?) can't verify all signatures,
  which gives a false sense of security for the undetactable forgeries.

  In case of PKCS7, it's possible to self-sign. Those we cannot
  check. In that case we remove the signature entirely from the MIME
  structure, so it doesn't look checked to the end-user.

  PGP cannot be checked, except it sort of can. We can have a small
  default keyring including the heise.de CA key and so on, and treat
  that as root CAs, using the keyservers to dig up intermediate keys.


PGP automatic processing

  Apparently there are five different PGP wrapping formats. We could
  detect four and transform them to the proper MIME format.


Get rid of FORTRAN typing

  Instead of using UString, we sometimes use String and "assume it to
  be UTF-8", except that sometimes we forget to assume that. Fix that.
  Also unfuck HeaderField::encode{Word,Phrase} in a different way -
  they use different tests for whether 2047 encoding is necessary, and
  I don't think either is right.


Plugins

  It's not given that we want to accept all mail. If we don't, who
  makes the decision? A sieve script may, and refuse/reject mail it
  does not like. And a little bit of pluginnery may. I think we'd do
  well to support the postfix plugin protocol, so all postfix policy
  servers can work with aox. (All? Or just half? Doesn't postfix have
  two types of policy plugins?)

  We may even support site-wide and group-wide sieve scripts and
  permit a sieve script to invoke the plugin. A sieve statement like
  this?

     UsePolicyServer localhost 10023 ;


BURL

  If the message is multipart and the boundary occurs in a part, that
  part needs encoding. Or else switch to a different body.


NOTIFY implementation

  Implement NOTIFY after revision -04 of the draft.


Cybertec replicator

  Is it good? What are people saying about it? What should we do about it?

  Ewald Geschwinde on IRC (the first time I've seen him; 2007-07-11) said:
  *egeschwinde* When I have time I will test your product on our
  multimaster cluster
  *egeschwinde* maybe also on the queuing system


DIGEST-MD5 reauth doesn't work for Dave Cridland

  (I haven't tried to reproduce it yet, because Polymer needs more
  Python stuff installed than I had the patience for.)


Delaying seen-flag setting

  We can move the seenflagsetter to imapsession, build up flags to
  set, flush the write cache before fetch flags, store, state-altering
  commands and searches which use either modseq or flags.

  This ought to cut down the number of transactions issued per imap
  command nicely.


Write howto/tls-certificate



The webmail thingy completely mangles patch attachments. :-(

  This would seem to apply to non-MIME attachments. How should we
  handle those? So far our Message class is completely predicated on
  MIME. Need an example of this, with an archives.oryx.com URL.


Make "aox check config" test for more things.

  Such as?


Per-group and systemwide sieves

  People always seem to want such things. It'll be easy to implement.
  Most of the tricky issues are described in
  http://tools.ietf.org/html/draft-degener-sieve-multiscript-00


The Sieve "header" test may fail

  Write a test or three that feeds the thing a 2047-encoded header
  field and checks that it's correctly matched/not matched. Then make
  it pass.


Listext::match() should use UString, not String

  It should also move elsewhere, so we don't have this evil
  inclusion. Where?


The subaddress specification says foo@ != foo+@ wrt. :detail

  The former causes any :detail tests to evaluate to false, while the
  latter treats :detail as an empty string. We treat both as an empty
  string.


Distribution packages

  - RPM: silug has offered to help.
  - FreeBSD port: devin (Tod McQuillin) has offered to help.
  - Debian: ? (license problems, but we could provide a .deb).
  - Ubuntu: ?


SMTP extensions

  Right now our list isn't well-considered, and we seem not to offer
  SIZE. Probably best to have a talk about which extensions are worth
  implementing.

  http://www.iana.org/assignments/mail-parameters


