2.08: 2008-04-07

  Web UI for setting up views. Also (less importantly) aox arguments
  for setting up views.

  Persuading ImapSession to do its flag updates using Store.  Move the
  SeenFlagSetter into ImapSession and delay setting \seen until we
  have to.

  Investigate Martin Rode's 3gb aox process. Update: Lots and lots of
  STATUS EXISTS would cause that.

  If the above sounds exactly like the plan for 2.07, perhaps it is.

  Restricting the use of SMTP submit, adding configuration. Perhaps:
  - a new toggle to decide whether problems with smtp submit cause 5xx
    after DATA or a bounce
  - a new toggle to decide whether the From field must point to some
    address the logged-in user is explicitly permitted to use (for
    example: it points to a mailbox for which the logged-in user has
    the 'p' right).
  - If we constrain From, then we check all of from, mail-from, sender
    and all resent-from addresses, and all must pass.
  - When we add DKIM signing (which isn't now), we sign only messages
    where the logged-in user is explicitly permitted to use the
    from/sender/etc addresses.

  nagios integration script

  2008-02-29: decide on feature list
  2008-03-24: drop things that can't be finished
  2008-03-31: fork and remove unusable code
  2008-04-03: roll, release chores
  2008-04-04: features for next release
  2008-04-07: release

  Done:
  - IMAP commands don't freeze

Release cycle

  Five weeks, t-35 to t (a Monday).

  t-38: we decide on a feature list for the release.

  t-14: Whatever hasn't been started is dropped, whatever cannot be
  completed before t-7 is laid aside for the next release. Write the
  announcement text.

  t-7: Fork the release and remove any code that needs to be removed.

  t-4: Roll the tarball and do the release chores.

  t-3: See t-38 above.

  t-0: A crontab does what it needs to do.


The value of features

  Archiveopteryx provides online archiving. We want the features we
  add to improve one or more of these:
  - adding mail to the archive
  - accessing the archive
  - managing the archive

  For nontechnical reasons I add a fourth goal:
  - making current users happy

  Each new feature should help in some way; the new features that help
  the most are the ones we need most (in the long term - in the short
  term we also need to help existing users).


The next eight months

  - Message retention
      User interface
      Message identification
      Logging changes to the message
  - aoximport improvements
  - Full text search
  - More documentation
      aox operations guide
      best practice papers
  - Better documentation
  - VIEW improvements
      INTHREAD
      multi-mailbox searches
      miscellaneous
  - Account management
      ACL management
      VIEW management
  - Recording the fate of outgoing mail
  - Proper full-text searching
  - Better exploratory search
  - Useful webmail
  - Address search
      Web UI
      IMAP X-extension
      Exporting to addressbooks
  - Monitoring
      Graphing


Items for web site

  In addition to stuff in the operations guide:

  - List/description of IMAP/POP/SMTP extensions
  - RFC pages
  - man pages (old ones too)
  - Source documentation
  - Best practices
  - FAQ
  - Version-specific pages
  - Download-specific pages
  - Client-specific pages


Installer doesn't take steps to ensure that the installation is usable

  It could do at least two things:

  Run all the same checks on the new installation as 'aox check' and
  archiveopteryx at startup.

  Try to connect to all the server addresses and if anything's
  listening anywhere, mention it on stdout.

  In addition to this, the installer does the wrong thing right now if
  it creates the database users and then fails to run psql to load the
  schema. It exits with an error, which means the randomly-generated
  passwords are lost, because the configuration file is not written.


Various TODO items from earlier releases.

  Message retention policy

  - Soft-quota/archival stuff too?
  - Message arrival tag (for archiving)

  aoximport could be much faster (disable indices, commit several
  thousand messages at a time in one big transaction), but it's a fair
  bit of work (unless aoximport has a private Injector or Injector can
  take a list of Message objets)

  Miscellaneous:

  - Database replication support (local mirror)
  - Split the injector transaction into fast and slow parts(?)

  THREAD?

  Basic administration using the httpd

  Indexing for DOC bodyparts

  aox backup/restore (or similarly helpful procedure)

  Full-text search


Not enough name resolution: db-address=localhost doesn't work.

  The name is resolved at startup, but nothing ever calls the resolver
  to retrieve the value. One way to fix this would be to make Endpoint
  itself accept names and resolve them. The downside is: what if there
  are multiple addresses, e.g. 127.0.0.1 and ::1?

  There are three cases, perhaps four:

  - Our own servers, where it's clear what should happen, and
    Listener::create() does the right thing.
  - Outgoing connections where we need a connection to any address.
  - Outgoing connections where we need a connection to each address.
  - Outgoing connections where >1 addresses is not meaningful, not
    tested or otherwise undesirable.

  Each user of Endpoint needs to handle this. That's Listener,
  Database, LogClient and OcClient, right? (SpoolManager/SmtpClient need
  to resolve an Endpoint too. bin/aox needs to be able to connect to the
  same things the Listener decides to listen to.)


Cleartext passwords

  We help migrating away from cleartext/plaintext passwords:

  1. We also store SCRAM and similar secrets in the DB (secrets which
     aren't password equivalents)
  2. We extend the users table with two new columns, 'last time
     cleartext was needed' and 'number of successful authentications
     without cleartext password usage since cleartext'.
  3. If a client uses SCRAM, we increment the counter.
  4. If a client uses CRAM or PLAIN, we reset counter and set the time
     to today.
  5. We provide some helping code to delete passwords for users with a
     high count and a long-ago time.
  6. We add documentation saying that if you disable auth-this and
     auth-that, you can disable store-plaintext-passwords.
  7. We add configuration/db sanity checks for ditto.


Login failures

  We want to log those a little more, and show them on the
  webmail/admin pages.

  Specifically, if user x cannot log in, what mechanism was used, what
  was the problem, etc?


Old logins

  If we log those to a log table, that table can be used to 
  - analyse login methods (ie. who needs passwords)
  - spot connection patterns and unusual connections
  - provide pop before smtp
  - do clever & smart vacation blah

  The table needs to store the client ip address, user name,
  connection start and end time, whether the authentication needed a
  cleartext password in the db and... what more?

  create table connections (
    user integer references users(id),
    mechanism varchar not null,
    authfailures integer not null,
    start timestamp with time zone not null,
    end timestamp with time zone,
    client varchar not null,
    syntaxerrors integer,
  );

  Syntax errors from the client and authentication failures both seem
  worth storing for later possible analysis.


Graceful shutdown

  When we decide to shut down, we should:

  1. Close all listeners. Log the shutdown. Abort those SMTP
     transactions which aren't currently in the responsibility
     transfer phase described by RFC 1047.

  2. Wait a second or two. Refuse new commands on existing connections
     (fuzzy logic needed to define "command" in that context). Don't
     start new database transactions.

  3. Close the remaining connections, implicitly rolling back database
     transactions. Quit.


aox check schema

  This command would check several things.

  a) that dbuser has the needed rights
  b) that all the right tables are there, and all the right columns,
     with the right types, and no unexpected constraints
  c) that all the right indexes are there
  d) that dbowner owns everything
  i) that inserts that would duplicate a constraint are properly
     recognised

  As a bonus, perhaps it could list some unexpected/unknown deviations:
  e) locally added tables
  f) locally added columns
  g) locally added indices
  h) missing constraints


  Change 43939 and following move towards this: the idea is to
  introduce new functions e.g. Schema::checkIntegrity (in addition to
  checkRevision) and Schema::grantPrivileges, that can be used both by
  aox check schema/aox grant privileges/whatever, and also by the
  installer (instead of lib/grant-privileges, and instead of the
  half-hearted checking it does now). the server is essentially
  unaffected, it just uses Database::checkSchema/checkAccess for a
  quick check.

  this sounds ok, but it's ugly because Schema::execute is completely
  given to upgrading the schema, and neither can nor should be
  repurposed to do other things besides. so that means more static
  functions in Schema and separate EventHandlers to do the
  checking/granting/whatevering. but that's okay.


Database schema range

  Poeple occasionally need to access the db with an old version of
  mailstore. I suggest that we:

  a) add a 'writable_from' column specifying the oldest version that
     can write to the database.
  b) add a 'readable_from' column specifying the oldest version that
     can read the database

  aox upgrade schema would update writable_from to the oldest schema
  version for which a writer would do the right job. This would often
  change when a table changes, but not when a table is added.

  readable_from would be the oldest revision that can read the database.

  When the server starts up, it would check:

  - am I >writable_from? If so, mailboxes can be read-write
  - else, am I >readadble_from? If so, startup can proceed, but all
    mailboxes are read-only. lmtp, smtp and smtp-submit do not start.
  - else, quit.

  And in order to handle database updates, I suggest another table,
  'features', with a single string column. When aox update database
  fixes something, it inserts a row into features. A modern database
  would have two rows in this table, 'numbered address fields' and 'no
  nulls in bodyparts'.


Sieve

  Alexey suggests the following extensions (in the following order):
  Vacation, reject, imapflags, subaddress.

  We still haven't done imapflags.

  Reject probably has changed since we implemented it.


Better caching.

  FieldNameCache etc. can use less memory by reading all field and
  flag names into RAM at startup. That way, the memory used won't be
  scattered across many blocks.


RFCs 2852 and 4865

  Easy to do once we have port 587; we need to set the start and end
  columns right, that's about it.


Message tracking

  RFCs 3885-8 specify ways to track messages that have been sent. We
  can implement that fairly easily.

  If we route outgoing mail via a smarthost, that smarthost has to
  support MTRK in order for tracking to work well.

  We can track mail provided that at least one of these is true:

  - we deliver directly to the end server (we don't know whether
    that's the case, though)

  - we deliver via an MTRK-capable server

  - we deliver into our own database

  Sounds likely to be true maybe 80-90% of the time.

  If none are true, we can at least say, easily, where we delivered,
  when, and why.

  We could implement the tracking protocol (and I'd write a query blah
  in mailchen), and also provide a query interface via the web.


Message tracking 2

  We can recognize the ESMTP id for the most common MTAs. Postfix says:

    250 Ok: queued as D1A324AC85

  Sendmaik and exim surely say something similar. We could keep that ID
  in delivery_recipients and use it in DSNs.


Generating bounces

  Our bounces would look better if they included the entire SMTP
  conversation (starting with RSET or EHLO).


Thread-Index from Exchange

  We could look at Thread-Index and reconstruct In-Reply-To in order to
  properly thread messages we a) aoximport from Exchange, or b) receive
  during a conversation with an Exchange user.


Bounces and DSNs

  Mail is currently fairly reliable. There is one big exception:
  Bounces aren't 100% parsable. But generally, if you work hard, you
  can know whether a message was delivered or not, and mostly they are
  delivered.

  So we benefit from converting the most common nonstandard bounces to
  DSNs, and then treat them as DSNs.

  For nonstandard bounces (like those of qmail) we identify the
  message by trying hard, do some hacky parsing, use the bounce
  (excluding trailing message) as first part of the DSN multipart,
  cook up a new DSN report based on the parsing, and save
  text/822-headers as a third part.

  Then, searches that tie bounces together with messages sent work
  even better.

  (Another trick we can/should use is to see whether the host we
  deliver to seems to be the final destination based on earlier
  (answered) messages.)


Memory use for common operations

  Some use _vastly_ too much memory. I saw a single IMAP FETCH for a
  mere 4200 messages use 173MB yesterday. (Later note: This should be
  gone, gone, gone, but it would still be good to check that these
  problems don't reappear, reappear, reappear.)

  The most elegant way to solve that would be to supervise memory
  usage for a known sequence. Inject these ten thousand messages,
  check memory use (via the grapher), connect to the imap port run
  this and that, check again, connect to the imap port run this and
  that, check again, connect to the imap port run this and that, check
  again... just a bunch of checks. Ignore output.


Deleting mailbox has unclear semantics now

  At present, we don't allow a mailbox to be deleted until all
  undeletable messages from that mailbox have been sent to the great
  mailbox in the sky.

  We might want to change that, but what then? What if someone wants
  to rename a new mailbox to the name that used to be taken by this
  mailbox? Or creates ditto? What should happen to views onto this
  mailbox?


3.0 changes

  - Don't announce digest-md5 by default.
  - PIDFILEDIR should be $(PREFIX)/lib/pidfiles.


MULTIAPPEND

  Stupid thing. Clients and servers using pipelining can do the same
  thing.

  But there it is, and change 52791 shows that if the injector learns
  to inject many addresses at at time, multiappend can be used to
  inject lots of messages quickly.

  aoximport can do it even better, of course.


imapd/handlers/acl.cpp

  Different tasks, some shared code, same file. Separate this out into
  different classes inheriting something. Then add the right sort of
  logging statement to the end of parse().


Opera often can't expunge

  Trace it once or twice, guess what's wrong.


ocd needs work (mike@waspfactory.org)

  1. The code (along with user/mailbox) needs cleaning up.
  2. Should synchronise field names etc.


AddressCache and FieldNameCache are utter crocks, and must die.


aox/conf/*

  Possible category pages, each listing all variables that influence
  blah

  conf/encryption
  conf/authentication
  conf/webmail
  conf/submission
  conf/imap
  conf/database

  More?


aox/conf/tls-certificate

  Those variables are not well described. We need a bit more.

  Also, -secret is probably misnamed, we use -password for other
  cases. I expect that's why aox show cf tls-certificate-secret yields
  while e.g. aox show cf db-password does not.


METADATA

  Needed for lemonade, as easy as annotate.


Autoresponder

  We have vacation now, but it isn't quite right for autoresponses.
  Sieve autorespond should be like this:

  1. :quote should quote the first text/plain part if all of the
     following are true:

     1. The message is signed, and the signature verified (using any
        supported signature mechanism, DKIM SHOULD be supported).
     2. The first text/plain part does not have a Content-Disposition
        other than inline.

     If any of the conditions aren't true, :quote shouldn't quote.

     If there's a signature block, :quote shouldn't quote that.

     If the quoted text would be more than ten lines, :quote may crop
     it down as much as it wants, ideally by skipping lines starting
     with '>', otherwise by removing the last lines.

  2. :subject, :from and :addresses as for vacation.

  3. :cc can be used to send a copy to the specified From address.

  4. The default :handle should not be based on the quoted text.

  5. Two text arguments, one for text before the quoted text, one for
     text after the quoted text.

  6. The autoresponse goes to the envelope sender, as some RFC
     requires. So we want an option to skip the response unless the
     return-path matches reply-to (if present) or From (unless
     reply-to is present).


Message arrival tag

  Once annotate is done, we want a tag, ie. a magic annotation which
  stays glued to the message wherever it goes, even after copy/move.

  We also want a way to store the original RFC822 format somewhere
  inside and/or outside the database, indexed by the arrival tag
  identifier. It's good if the tag is split, so we can have "x-y"
  where X is the CD/DVD number and Y is the file on the CD/DVD. Or
  something like that.


Message Retention Policy Framework

  A lot of sites will want explicit policies regarding what mail may
  not be deleted, what may be deleted, and what must be deleted. We
  can support that well.


C/R

  C/R sucks. But it has its uses, so we can benefit from implementing
  it somehow. Here are some classes of messages we may want to treat
  specially:

  - replies to own mail
  - messages in languages not understood by the user
  - mail from previously unknown addresses
  - mail from freemail providers
  - vacation responses from unknowns
  - messages likely, but not certain to be out-of-office-autoreply
  - dkim/mass-signed messages (if verified)

  The questions are: How can we ensure that we almost never challenge
  real mail, while simultaneously challenging most/all messages that
  don't come from valid senders? How can we provide suitable
  configuration?


Using rrdtool

  What could we want to graph with rrdtool? Lots.

  - CPU seconds used
  - database size
  - messages in the db
  - average response time
  - 95th percentile response time
  - messages per user
  - message size per user
  - average query execution time
  - average query queue size

  More?

  http://jwatt.org/svg/authoring/ is interesting for generating graphs
  via the web interface.


Box features

  1. web ui to set up view mailboxes (and to search the archive
     generally)

  2. web ui to configure sieve

  3. web administration, to add users, etc.

  4. i18n for all web-accessible anythings, and after that, for aox.

  5. rrd stuff available next to aox in the boxes, perhaps nagios
     stuff too


SASL NTLM authentication

  It may be odd and undocumented, and it may not be as strong as
  DIGEST-MD5, but it's implemented in Certain Clients ;)

  http://www.innovation.ch/java/ntlm.html seems to be a reasonable
  description. Cyrus also implements it.

  http://davenport.sourceforge.net/ntlm.html ?


DELETE of mailboxes in inappropriately qualified (security problem)

  At present, the user always needs to have all three rights, and
  there's a race condition against append/copy. It would be better to
  grab the uidnext lock and do more fine-grained checking:

  1. Require DeleteMessages unless all messages have \deleted.

  2. Require Expunge if there are any messages at all.

  The race condition means it's possible to append to a mailbox while
  it's being deleted, and the message will reappear if the mailbox is
  later recreated. We could solve the latter by emptying the mailbox
  at recreate time.


Split the folder view into pages.

  Need to decide on what a page is. "Most recent 25 threads" is a
  slippery concept when a new thread is created between page views.

  One probably good way: Use "after" and "before", so "next" would
  point to "most recent 25 threads after the last one on this
  page". Doable, not bad, and with the aid if a new Session subclass
  we can even include a note when there's new activity.


We should be able to use a read-only local database mirror.

  That way, we can play nicely with most replication systems.

  The way to do it: add a new db-mirror setting pointing to a
  read-only database mirror. all queries that update are sent to
  db-address, all selects are sent to db-mirror. db-mirror defaults to
  db-address.


Add Maildir support to the migrator.

  Currently works, with two exceptions: Submaildirs don't work, and
  courier's extended flags don't work.


We should test multipart/signed and multipart/encrypted support.

  We must add a selection of RFC 1847 messages to canonical, and make
  sure they survive the round trip. No doubt there will be bugs.


We should store bodyparts.text for PDF/DOC.

  We need non-GPLed code to convert PDF and DOC to plaintext.

  Or maybe we need a generic interface to talk to plugins.


Switch to using named constraints everywhere.


Default c-t-e of PGP signatures

  Right now we give them binary. q-p or 7bit would be better, I think.

  What other application/* types are really text?

  From a conversation the other day: we could avoid base64 encoding an
  entity whose content-type is not text if it contains only printable
  ASCII. I don't know if it's worth doing, though.

  The problem with doing that is that it treats sequences of CR LF, CR
  and LF as equivalent. An application/foobar object that happens to
  contain only CR, LF and printable ASCII can be broken.


Something like soft-bounce might just be useful

  enabled: smtp/lmtp always give 4xx errors. disabled: either 4xx or
  5xx depending on the type of error.


recognising spam

  The good spam filters now all seem to require local training with
  both spam and nonspam corpora. We can do clever stuff... sometimes.

  Instead of filtering at delivery, we can filter when a message
  becomes \recent. When we increase first_recent, we hand each new
  message to the categoriser, and set $Spam or $Nonspam based on its
  answer.

  This lets the categoriser use all the information that's available
  right up to the moment the user looks at his mail.

  We can also build corpora for training easily. All messages to which
  users have replied are nonspam, replies to messages from local users
  are nonspam, messages in certain folders are spam, messages with a
  certain flag are spam.

  We can connect to a local server to ask whether a message is spam.
  They seem to work that way, but with n different protocols.


Replace Mailbox::isHome with something correct.

  It should look for a mailbox whose owner is different from its
  parent's owner.


TLS client support (smtp, postgresql)


"Writing Secure Code"

  We have a page about security, /mailstore/security.html, and a
  section of the mailstore.7 man page mentions it too.

  We need to look at ISBN 0735617228 and improve security.html with
  points from it. It could also be that we'll improve the code itself.


udoc stuff:

  1. Support a single level of nested classes. (What file names to use
     for output?)
  2. Support enum annotation.
  3. Suppress empty <p>, duplicate anchor names in output.


Udoc web pages chores

  Add "Related Pages" etc. Clarify where background.html
  fits. usage.html is an orphan now; should it become a manpage?


Play with PITR and write /ams/pitr.html


Document IPC structure

  Some man page, or some web page, or both, should say who's
  connecting to who and why.


Add a web page about the charset encoding.

  It's a novel and good algorithm, so we can make a good page about
  it. We also can link to data sources there.

  The documentation for Codec::byString() should mention that page's
  URL.


Make a web page about our licensing

  Not sure what to say there. the purpose of the page would be to
  direct people to one of the two others, really. and to be linked to
  from the home page.


The "Database" link on home page

  Where should it go? People might click it wondering why to use a
  database instead of flat files and wanting to know what we do with
  databases.


Interop pages

  A variety needed.


Protocols supported

  A list detailing what our general idea is (internet standard,
  interoperability, utility) and linking to each actual protocol page.

  The URL for this is difficult.


Search ourselves, not via google

  Or maybe farm that out, get google to search with an approximation
  of our design. http://www.google.com/faq_freewebsearch.html may be
  interesting.


Fix shutdown

  There's no practical way to shutdown using ocd/ocadmin. Perhaps this
  is another aspect of the problem above.


Logging to syslog

  The logd HUP handler can switch to syslog if it can't reopen the
  logfile instead of exiting.


Rendering webmail HTML is presumably good, but...

  We have a potential security hole: A malevolent HTML bodypart is
  forwarded as is on the "download bodypart" page.

  See http://ha.ckers.org/xss.html


When TlsServer dies, imaps (993) must go away

  It doesn't at the moment. Anything else?


Faster mapping from unicode to 8-bit encodings

  At the moment, we use a while loop to find the right codepoint in an
  array[256]. Mapping U+00EF to latin-1 requires looping from 0 to
  0xEF, checking those 239 entries.

  We could use a DAG of partial mappings to make it faster. Much
  faster. Mapping U+20AC to 8895-15 would require just one lookup: In
  the first partial table for 8859-15. Mapping U+0065 to 8859-15 would
  require three: In the first (U+20AC, one entry long), in the
  fallback (U+00A0, 96 entries long) and in the last (U+0000, 160
  entries long).

  Effectively, 8859-15 would be a first table of exceptions and then
  fall back to 8859-1.

  The tables could be built automatically, compiled in, and would be
  tested by our existing apparatus.

  Or we could do it simpler and perhaps even faster: Make a local
  array from unicode to target at the start, fill it in as we go, and
  do the slow scan only when we see a codepoint for the first time.


Multipart/signed automatic processing

  We could check signatures automatically on delivery, and reject bad
  signed messages.

  The big benefit is that some forgeries are rejected, even though the
  reader and the reading MUA doesn't do anything different.

  The disadvantage is that we (probably?) can't verify all signatures,
  which gives a false sense of security for the undetactable forgeries.

  In case of PKCS7, it's possible to self-sign. Those we cannot
  check. In that case we remove the signature entirely from the MIME
  structure, so it doesn't look checked to the end-user.

  PGP cannot be checked, except it sort of can. We can have a small
  default keyring including the heise.de CA key and so on, and treat
  that as root CAs, using the keyservers to dig up intermediate keys.


PGP automatic processing

  Apparently there are five different PGP wrapping formats. We could
  detect four and transform them to the proper MIME format.


Plugins

  It's not given that we want to accept all mail. If we don't, who
  makes the decision? A sieve script may, and refuse/reject mail it
  does not like. And a little bit of pluginnery may. I think we'd do
  well to support the postfix plugin protocol, so all postfix policy
  servers can work with aox. (All? Or just half? Doesn't postfix have
  two types of policy plugins?)

  We may even support site-wide and group-wide sieve scripts and
  permit a sieve script to invoke the plugin. A sieve statement like
  this?

     UsePolicyServer localhost 10023 ;


BURL

  If the message is multipart and the boundary occurs in a part, that
  part needs encoding. Or else switch to a different body.


NOTIFY implementation

  Going there...


Cybertec replicator

  Is it good? What are people saying about it? What should we do about it?

  Ewald Geschwinde on IRC (the first time I've seen him; 2007-07-11) said:
  *egeschwinde* When I have time I will test your product on our
  multimaster cluster
  *egeschwinde* maybe also on the queuing system


DIGEST-MD5 reauth doesn't work for Dave Cridland

  (I haven't tried to reproduce it yet, because Polymer needs more
  Python stuff installed than I had the patience for.)


Delaying seen-flag setting

  We can move the seenflagsetter to imapsession, build up flags to
  set, flush the write cache before fetch flags, store, state-altering
  commands and searches which use either modseq or flags.

  This ought to cut down the number of transactions issued per imap
  command nicely.


The web interface should offer a download link for attachments.

  For patches attached as text/plain with the right Content-Disposition,
  for example.


Per-group and systemwide sieves

  People always seem to want such things. It'll be easy to implement.
  Most of the tricky issues are described in
  http://tools.ietf.org/html/draft-degener-sieve-multiscript-00


The Sieve "header" test may fail

  Write a test or three that feeds the thing a 2047-encoded header
  field and checks that it's correctly matched/not matched. Then make
  it pass.


The subaddress specification says foo@ != foo+@ wrt. :detail

  The former causes any :detail tests to evaluate to false, while the
  latter treats :detail as an empty string. We treat both as an empty
  string.

  (We could set detail to a single null byte, to \0\r\0\n\0, to a
  sequence of private-use unicode characters, or even to
  Entropy::string( 8 ) if there is no separator. The chance of that
  appearing in an address is negligible.)


Distribution packages

  - RPM: silug has offered to help.
  - FreeBSD port: devin (Tod McQuillin) has offered to help.
  - Debian: ? (license problems, but we could provide a .deb).
  - Ubuntu: ?


SMTP extensions

  Here are the ones we still don't implement, but ought to implement
  at some point:

  SUBMITTER? perhaps
  DELIVERBY (RFC 2852): At some time.
  FUTURERELEASE (RFC 4865): At some time.
  MTRK: As soon as someone else does it.

  http://www.iana.org/assignments/mail-parameters


SUBMITTER

  The work needed to support that:

  1. Pass a submitter to SmtpClient.
  2. Pass the sieve owner or logged-in user's address as submitter.
  3. Send that as SUBMITTER= if the smarthost advertises SUBMITTER and
     the submitter is different from mail-from.

  4. Advertise SUBMITTER.
  5. If the SMTP/LMTP/Submit client sends SUBMITTER and it's different
     from the mail-from, record the address in Received.
  6. If there's a sieve extension specifying how, push the submitter
     into the envelope so the sieve can see it.

  Easy peasy. But there's no value to offset this (small) cost, is
  there? Maybe as a hack when one of us is fed up.


SSL/TLS hello

  When a client sends us SSL or TLS hello instead of the appropriate
  protocol, wgat do we want to do? Two options:
  - Silently start TLS.
  - Send some sort of server hello saying "no, my friend"

  Connection could have a utility function to look at whether the next
  few bytes on the incoming connection match a TLS/SSL hello, and each
  subclass could make the choice for itself. I think the real
  protocols would want to say no, and HTTP might want to do something
  else.


The groups and group_members tables seem a little underused

  We do not use them at all. We meant to use them for "advanced" ACL
  support, but nobody ever asked, and it didn't seem worthwhile.

  I now think it's worthwhile.

  Here's what I want to add:

  Make a superusers group, which members can authenticate as anyone,
  and the notion of group admins, who can authenticate as other
  members of the group.

  Or maybe an adminintrator table, linking a user to either a group or
  to null. If a group, then the admin can authenticate as other
  members of that group and (importantly) has 'a' right on their
  mailboxes, if null, then ditto for all groups.

  Extend Permissions to link against group_memebers when selecting
  applicable permissions.

  Make groups be permissible ACL identifiers.


We need to be able to disable users

  - Reject mail with 5xx/4xx.
  - Prevent login.
  - 1+2.
  - a group admin can enable/disable group members
  - a superadmin can enable/disable anyone
  - a group admin cannot unblock an overall blockage


Using whirlpool instead of MD5.

  I get the impression that conventional opinion is slowly moving
  towards whirlpool as the hash function of choice. At some point we
  want to use it instead of MD5 for the bodyparts table.

  I don't want to use SHA* functions, they're too similar to
  MD5. Those aren't worth the move.

  Two ways to move to Whirlpool:

  1. Recompute all the hashes and update the table.

  2. Just start inserting whirlpool hashes in the hash column, and
     accept that if the same bodypart was inserted by an older
     version, we'll store it twice.

  I don't want to bother with the expensive rehashing. But maybe
  people will be unhappy and ask us to do it as an aox command.

  It seems that netbsd includes a whirlpool implementation.


Assigning the "l" right automatically hurts shared hosting.

  Casey Shobe <casey@shobe.info> wants to host multiple customers in a
  single Archiveopteryx installation, and doesn't want them to be able
  to see each other's mailboxes. We could support that now (2008-01).


Showing email addresses in public archives is... well...

  There are three common solutions:

  1. Show the address. What we do now. Gives addresses to spammers,
     which is undesirable.

  2. Replace @ with at or some other easily reversible change. I
     assume gigamega.com, litefinder.net and other address scrapers
     already detect the common obfuscations, so this is pointless.

  3. Show part of the address, e.g. arnt@ory... or
     ar...@oryx.co... for arnt@oryx.com. Isn't reversible, so the
     spammers can't undo it, but also makes the archive less usable
     for people.

  We might change to 3, but with a captcha-protected option to show
  1. That would give us all the advantages and no serious disadvantage.
  But we would have to implement captchas somehow, which would be a
  moderate pain.


aox.org/badmail/

  Explain that aox can't store everything, why not (in short), that it
  has many workarounds and point to examples/, how to detect/report
  bad messages and how to fix things with reparse. Point to
  /aox/reparse for more detail.

  Subpages:

  badmail/examples/n for 1<=n<=8, with good and bad blah, generated
  from chosen canonicals, to show how we fix things up. Each page
  showing old and new, with differences indicated, and they should be
  ordered from reasonable/common to outrageous.

  badmail/examples/ summing up 1-8 and giving one or two truly
  hopeless cases. The hopeless case(s) should also be shown in
  anonymised form.

  badmail/examples/comparison if I feel nasty and bored one day,
  showing how a few IMAP servers handle messages 1-8 and the
  impossible one(s). Does "fetch envelope" return the right thing? 
  "fetch bodystructure"? Some choice searches? We don't want to link
  to this page very much. It gets a fine <table> containing many/few
  &#x2713; cells.

  Possibly we want to include screenshots showing how Thunderbird or
  another GUI client that uses envelope/bodystructure renders a
  mailbox containg 1-8. Screenshots using aox and using another
  server, one that gets few &#x2713; cells in the table. I'm not sure
  where to link to these screenshots. Apple Mail?

  We also need aox.org/aox/reparse and I suppose other /aox/<command>
  pages.


Redoing Store

  Store is too complex and sometimes rather too slow. I saw one take
  20 minutes just now. Here's how I want to improve matters:

  1. Select nextmodseq for update and get a value.

  2. Make a Selector using 
     a) the UID set supplied by the client.
     b) UNCHANGEDSINCE, if supplied
     c) Each postcondition. For example, STORE +FLAGS \seen should set
        \seen, so we can exclude messages that already have \seen.

     select mailbox_messages where (all that) for update

     If the result set is empty, stop at this point.

  3. This step depends on what we're doing. If it's +flags, this is a
     COPY, if it's -flags, this is DELETE. And so on.

  4. Update mm.modseq on the rows returned by step 2. Carefully use
     addGapsFrom to trim the size of the condition.

  6. Update nextmodseq and go on our way.


String::stripWSP

  The function seems to be just wrong every time I want to use
  it. There is also the matter of the name, which implies that the
  function changes. Look at it.


Fetcher oomph

  The fetcher is hard to use and doesn't perform as well as one might
  wish. I see several problems.

  1. There's an undeclared cursor. Each of the five fetchers does the
     longwinded equivalent of 'select 64 from cursor'.

  2. There's evil repetition among the fetchers. Fetching rfc822 runs
     the very same "select message from mailbox_messages where
     mailbox=$1 and uid..."  three times and then feeds the output of
     that into a fetcher-specific query.

  3. Each caller has to create up to five objects with basically the
     same arguments, and call execute on each.

  So I'd prefer to do it differently. Create one fetcher, tell it
  which kinds of blah you want, and it will run _one_ "select message
  from", feed that into a something, then run up to five selects that
  act on the output of the first select.

  Each of the five need to use a cursor (to avoid memory explosion in
  case the client fetches 400,000 messages and one select is much
  faster than the others). There has to be a transaction, n selects
  and n+1 cursors, one of which is SCROLL.

  First, to get the messages

    declare m scroll cursor for
    select messages,uid from mailbox_messages
    where uid>=$1 and uid<=$2 and mailbox=$3

  Then, to get e.g. header fields:

    declare hfm no scroll cursor for
    select m.uid, h.part, h.position, f.name, h.value from h
    join field_names f on (h.field=f.id)
    join (fetch absolute all from m) m using (message)
    where h.field > 12 order by m.uid, h.part

  I think we might see a speedup of 2-100x depending on task. Unless
  we use all this apparatus for single-message fetches.


aox.org/clients/

  Move the list of clients from /imap/ and /pop here. Make a per-client page,
  e.g. /clients/outlook, with notes.

  1. Which protocols can use you use? Usually IMAP+Submit.

  2. Any bugs worth speaking of?

  3. Any particular configuration advice? for /clients/outlook we say
     "enable use-smtps". For /clients/applemail we point to that IDLE
     plugin.

  That's it, right?


/archiveopteryx/jquery.js

  Serving our own copy of jquery.js (which both Arnt and I agree is
  desirable) would involve the following:

  - Subclassing WebPage to allow us to serve the contents of jquery.js
    as application/x-javascript (or whatever). We'll have to store the
    javascript source in some C-escaped form in the source.

  - Adding a { Magic, Suffix } handler, and mapping "jquery.js" to a new
    Suffix type (JQuery).

  - Returning a page of the newly-created type from the link handler.

  A related question: is /archiveopteryx meant to be under /webmail, or
  is it (as some comments suggest, while others disagree) meant to be a
  top-level directory? If it's the latter, the code will have to change
  a little.

  All of this also applies to favicon.ico (for which we have a Link
  type, which we do not currently handle) and default.css (which we
  make no attempt to serve a local copy of).



