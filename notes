Next release (2006-05-08: 1.06)

  Done:

  - ms add/del/add mailbox fix.
  - Create /usr/local/archiveopteryx/messages automatically.
  - Allow UTF8 instead of UNICODE for Postgres encoding.
  - Make installer check permissions and ownership.
  * Build correctly on 64 bit systems. (done, including makefile)
  - Makefile now displays correct post-installation message.
  - The beginnings of a MANAGESIEVE server.
  - Fix "USER bad" followed by "USER good" in POP3.
  * Add TOP and UIDL support to POP3.
  - Add checkFilePermissions() to ms.
  * Rename ms to aox.
  - Rename rcarchiveopteryx to archiveopteryx.
  - Install expanded README to $READMEDIR.
  - lib/archiveopteryx status
  - Assorted udoc fixes.
  - Content-Location/Content-Base parsing.
  - MkDir moc's LOCATE_TARGET and man3/html after jam clean.
  - Delete views based on view as well as source.
  - Fix two rename bugs: bad inbox in aliases, and uidvalidity=0.
  - Add derivations from Garbage to fix some segfaults.
  - Add "aox change username ..." (Thomas)
  - Add "aox change address ..." (Thomas)
  - Fix the i/97 problem.
  - Don't set needHeaders to false in FETCH.
  - Generate a more verbose configuration file.
  - A more cooperative init script (RedHat, SuSE/LSB).
  - "aox show build" includes buildinfo.
  - SASL infinite loop fixed.
  - aox list aliases

  Must-Do:

  - Update everything that talks about 'imapd(8)' and other extinct
    manpages.

  Desired:

  - Extra indexes where needed.
  - Properly working tsearch2.
  - Webmail archive pages.
  - DNS lookups for configuration variables


Next few releases

  - SORT/THREAD
  - Working webmail
  - More character encodings (EUC-KR)


ocd needs work (mike@waspfactory.org)

  1. The code (along with user/mailbox) needs cleaning up.
  2. Should synchronise field names etc.


Don't duplicate the contents of address_fields in header_fields.

  The Injector should avoid inserting address fields into header_fields,
  and the HeaderFetcher should assemble addresses from address_fields.


We need to support date field searches.


AddressCache and FieldNameCache are utter crocks, and must die.


Consider RFC2231:

  2231 says: IMAP4 [RFC-2060] servers SHOULD decode parameter value
  continuations when generating the BODY and BODYSTRUCTURE fetch
  attributes.

  Hopefully we don't need to care about this at all.

  Arnt's opinion: We're better off doing that at parse time. There's
  also some outlook breakage to support - it uses 2047 when it
  shouldn't.


Clean up SubDir/SubInclude

  Rename them as Modules. Module X, Use X. Tie library use and headers
  to modules, so users get just the -I and -l arguments needed from
  the modules used (even if the entire tree is being compiled).

  This turns out to be a little harder than I thought. Basically we'd
  want include directories to follow the Build rule, not the SubDir
  rule.


ANNOTATE support

  Annotations are good. We want them. They're easy for us. By now the
  draft should be stable, so we can implement whenever we want to and
  have the time.

  Status:
  - schema changes: done
  - session state: done
  - SELECT/EXAMINE: done
  - FETCH: written, not tested, probably broken
  - STORE: done, currently broken
  - COPY: done (untested for lack of other support)
  - APPEND: can call code currently in STORE
  - SEARCH: done
  - SORT


ANNOTATEMORE

  Ditto. Separate point so that we can do one without the other.


We need a SIEVE interpreter.


Autoresponder

  We'll need one, nicely programmable, connected to our sieve.

  I was reminded of this by Google's wording:

  Thank you for writing to Google. This automated response is just to
  let you know that we've received your email, and you'll hear from us
  soon.

  Thank you for using Google.

  Regards,
  The Google Team


Message arrival tag

  Once annotate is done, we want a tag, ie. a magic annotation which
  stays glued to the message wherever it goes, even after copy/move.

  We also want a way to store the original RFC822 format somewhere
  inside and/or outside the database, indexed by the arrival tag
  identifier. It's good if the tag is split, so we can have "x-y"
  where X is the CD/DVD number and Y is the file on the CD/DVD. Or
  something like that.


Message Retention Policy Framework

  A lot of sites will want explicit policies regarding what mail may
  not be deleted, what may be deleted, and what must be deleted. We
  can support that well.


C/R

  C/R sucks. But it has its uses, so we can benefit from implementing
  it somehow. Here are some classes of messages we may want to treat
  specially:

  - replies to own mail
  - messages in languages not understood by the user
  - mail from previously unknown addresses
  - mail from freemail providers
  - vacation responses from unknowns
  - messages likely, but not certain to be out-of-office-autoreply

  The questions are: How can we ensure that we almost never challenge
  real mail, while simultaneously challenging most/all messages that
  don't come from valid senders? How can we provide suitable
  configuration?


We should figure out some way to not store plaintext passwords.


SASL NTLM authentication

  It may be odd and undocumented, and it may not be as strong as
  DIGEST-MD5, but it's implemented in Certain Clients ;)

  http://www.innovation.ch/java/ntlm.html seems to be a reasonable
  description. Cyrus also implements it.


httpd segfaults when you click on a message (Harri).


Make the httpd do archive pages

  Shouldn't we be most of the way there? Need partial result pages and
  real searching, though.

  Notify denis@startsiden.no when external testers might want to look
  at it.


archives.oryx.com

  Mostly need httpd archiving.


Miscellaneous cleanups:

  * Get rid of Blah::setup wherever possible
  * Avoid unnecessary header file inclusion
  * Enable the #ifdef'ed out tests
  * Do the "uint characters[256]" thing to simplify parsing.


DELETE of mailboxes in inappropriately qualified (security problem)

  At present, the user always needs to have all three rights, and
  there's a race condition against append/copy. It would be better to
  grab the uidnext lock and do more fine-grained checking:

  1. Require DeleteMessages unless all messages have \deleted.

  2. Require Expunge if there are any messages at all.

  The race condition means it's possible to append to a mailbox
  while it's being deleted, and the message will reappear if the
  mailbox is later recreated.


Split the folder view into pages.

  The injector needs to do threading to make the paging possible.


The tsearch2 trigger doesn't work

  "Can't find configuration by locale" errors, and they make the
  Injector very unhappy.


A failing parse message should invalidate the prepared statement cache.


Look into supporting the MySQL protocol after 1.0


Orphaned bodyparts should be cleaned up somehow.

  'ms vacuum -b' now does this, but it requires a full-table lock on
  mailboxes in order to not zap bodyparts that the injector hasn't
  linked to part_numbers yet (cf. injector.cpp:640).

  Unfortunate, but how can it be done better without savepoints?


We need mUTF-7 support.


Write better field wrapping code

  HeaderField::wrap is terribly hackish right now. Besides, ::unwrap()
  should become the higher-level parser's job.


We should be able to use a read-only local database mirror.

  That way, we can play nicely with most replication systems.

  The way to do it: add a new db-mirror setting pointing to a
  read-only database mirror. all queries that update are sent to
  db-address, all selects are sent to db-mirror. db-mirror defaults to
  db-address.


canonical and deliver need severe cleaning up.


Write a valgrind skin that should help us to diagnose memory abuse.


Read the GiST papers and look at tsearch2 again.


migrator should work without indices

  If the database is otherwise idle, the migrator could disable indicex
  and perhaps transactions, and go much faster.


Add Maildir support to the migrator.


Get more word lists for Codec::byString( const String & )

  Word lists need to contain at least one non-ASCII character, and to
  be fairly common words.


We should test multipart/signed and multipart/encrypted support.

  We must add a selection of RFC 1847 messages to canonical, and make
  sure they survive the round trip. No doubt there will be bugs.


Something confuses Address::uname() and Address::name()

  As a result, we send unlabelled 8-bit content in display-names if
  the name cannot be expressed in either 8859-1, 8859-2 or koi8-r.

  I think the underlying reason is that we're not using UString, so
  the compiler's type checking does nothing for us.

  This is easy to demoonstrate with 22 right now, but it won't be
  shortly - I'll make a separate change which accidentally obliterates
  the difference.


We should store bodyparts.text for PDF/DOC.

  We need non-GPLed code to convert PDF and DOC to plaintext. We already
  use the code from Mailchen to convert HTML.


CAcert instead of self-signed certificate?

  www.cacert.org offers free certificates and seems to be an
  up-and-coming thing.  In a few months, we may want to add 'obtain
  valid cert from cacert'.

  Btw, cacert.org is a very nice place to get praise and a link from. High
  nerd factor. If we have the first really-easy-to-use interface to
  get cacert interfaces into a program, they'll do that, no doubt.


Switch to using named constraints everywhere.


Default c-t-e of PGP signatures

  Right now we give them binary. q-p or 7bit would be better, I think.

  What other application/* types are really text?

  From a conversation the other day: we could avoid base64 encoding an
  entity whose content-type is not text if it contains only printable
  ASCII. I don't know if it's worth doing, though.

  The problem with doing that is that it treats sequences of CR LF, CR
  and LF as equivalent. An application/foobar object that happens to
  contain only CR, LF and printable ASCII can be broken.


The IMAP SORT extension seems really easy

  Squirrelmail wants it. Strongly. And it's not terribly difficult to
  implement, to put it mildly.

  Interacts with ANNOTATE.


The flag_names has the wrong constraint

  Flag names are case insensitive, but the database constraint assumes
  that they are case sensitive.

  Maybe we should rather use unique(lower(name)).


GC speedups

  At the moment, sweep() tends to look at all of RAM. if we move the
  .marked bits into a bitmap like the "allocated" bitmap, we can avoid
  that.

  It would also be very good if we could avoid sweeping every
  Allocator during every sweep. Perhaps we should sweep only
  Allocators that are full or have seen some activity. Or something.


String allocation is about half as fast as it could be

  String and StringData are allocated independently. String could
  override the allocation method and allocate sizeof( String ) +
  sizeof( StringData ), and then forcibly set d.

  The same applies to other classes which we instantiate very often.


Something like soft-bounce might just be useful

  enabled: smtp/lmtp always give 4xx errors. disabled: either 4xx or
  5xx depending on the type of error.


recognising spam

  The good spam filters now all seem to require local training with
  both spam and nonspam corpora. We can do clever stuff... sometimes.

  Instead of filtering at delivery, we can filter when a message
  becomes \recent. When we increase first_recent, we hand each new
  message to the categoriser, and set $Spam or $Nonspam based on its
  answer.

  This lets the categoriser use all the information that's available
  right up to the moment the user looks at his mail.

  We can also build corpora for training easily. All messages to which
  users have replied are nonspam, replies to messages from local users
  are nonspam, messages in certain folders are spam, messages with a
  certain flag are spam.

  We can connect to a local server to ask whether a message is spam.
  They seem to work that way, but with n different protocols.


predictive db fetching

  This change adds a hack to imapd/handlers/fetch.cpp, to defeat
  pessimal clients like thunderbird.

  It's inchoate.

  It seems to me that the proper way would be to record something in
  MessageFetcher and extend fetches there. For example, keep a cache
  of (fetch type, mailbox, uid, uid range) tuples. Each fetch creates
  one such tuple. If the fetch includes the uid, it's expanded by the
  uid range. If the fetch is not predicted by any tuple, add a new
  tuple for the n UIDs following the highest requested UID.


Losing all PSQL connections is bad

  If we have no connections, need to open one and can't, we ought to
  shutdown. Log a disaster, shutdown all servers.


Replace Mailbox::isHome with something correct.

  It should look for a mailbox whose owner is different from its
  parent's owner.


TLS client support (smtp, postgresql)


We MUST support HTTPS for the webmail interface.


"Writing Secure Code"

  We have a page about security, /mailstore/security.html, and a
  section of the mailstore.7 man page mentions it too.

  We need to look at ISBN 0735617228 and improve security.html with
  points from it. It could also be that we'll improve the code itself.


udoc stuff:

  1. Support a single level of nested classes. (What file names to use
     for output?)
  2. Support enum annotation.
  3. Suppress empty <p>, duplicate anchor names in output.


Udoc web pages chores

  Add "Related Pages" etc. Clarify where background.html
  fits. usage.html is an orphan now; should it become a manpage?


Play with PITR and write /ams/pitr.html


Update doc/recorder.man

  Must decide whether to use .SS or .IP, etc.


Document IPC structure

  Some man page, or some web page, or both, should say who's
  connnecting to who and why.


/events/solutionslinux-2006.html needs a plausible audience/task.

  We'll use that to do a better job of /events/linuxtag-2005.html


Add a web page about the charset encoding.

  It's a novel and good algorithm, so we can make a good page about
  it. We also can link to data sources there.

  The documentation for Codec::byString() should mention that page's
  URL.


Make a web page about our licensing

  Not sure what to say there. the purpose of the page would be to
  direct people to one of the two others, really. and to be linked to
  from the home page.


The "Database" link on home page

  Where should it go? People might click it wondering why to use a
  database instead of flat files and wanting to know what we do with
  databases.


Interop pages

  A variety needed.


Protocols supported

  A list detailing what our general idea is (internet standard,
  interoperability, utility) and linking to each actual protocol page.

  The URL for this is difficult.


Search ourselves, not via google

  Or maybe farm that out, get google to search with an approximation
  of our design. http://www.google.com/faq_freewebsearch.html may be
  interesting.


Fix shutdown

  There's no practical way to shutdown using ocd/ocadmin. Perhaps this
  is another aspect of the problem above.


Resource limits on memory allocation


Logging to syslog

  logfile=syslog:local2 could mean "log to syslog with the local2
  facility". that's ugly syntax. parsing and blah.

  if we implement this, the logd HUP handler can switch to syslog if
  it can't reopen the logfile.


ms migrate -n

  'ms migrate -n' could write an 1-2-line description of the first
  schema upgrade to be done, do it, report whether it failed, then
  roll the transaction back instead of committing it.


ms restart and ms start don't check all they could

  Improvements:

  1. ms restart and ms start should bind to the IP addresses specified
     by all the relevant servers (but not the ports) and try to
     connect to the ports.

  2. ms restart can issue 'ms start' when the last established
     connection dies. currently it calls sleep(1).

  3. ms start can expect all the connects to fail. if a connect
     succeeds, someone else is using that port, so our server won't.

  4. Both of them should expect all the binds to succeed. if not,
     mailstore.conf contains a bad address.


"ms check" works... uh...

  To see it, add "loglevel=debug" to mailstore.conf and run ms
  check. You'll get exactly the message you should.

  Now change it to "log-level=debug" and rerun ms check.


Privilege separation

  We talked about privilege separation. One pgsql user to update the
  schema, another to read mail.

  How about deleting things? Is that something we might want to
  restrict?

  Somehow I feel more and more uncertain each time I type
  'delete from messages where mailbox>6;' or similar commands.

  Pergaps privilege separation could be used to grant me rm -rf access
  to the regular database, but build a higher wall on kalyani. Sounds
  good.


Make User::create/remove work like Mailbox::create/remove. (AMS)


Make sure UIDs never exceed 2**31 (and break getInt).


\Recent is broken in a number of ways on views.

  - SessionInitialiser doesn't update first_recent after extending
    uidnext for views.
  - Selector uses d->session's Recent map, but SEARCH passes in the
    source mailbox's UIDs.


Rendering webmail HTML is presumably good, but...

  Knowledge is better than presumption.

  Webmail services have a lot of known holes. Cross site scripting and
  suchlike. We can add known sploits/demos to our rendering tests, and
  check that we're not vulnerable.

  Two I saw today: http://www.sec-consult.com/232.html and
  http://www.sec-consult.com/233.html


Making injection faster.

  If we use a separate transaction to acquire the UID, then we hold
  the mailbox lock for (how much?) less time.

  We hold the lock MUCH shorter. Just enough to 'select x for update',
  'update x' and commit, which is pretty close to the shortest possible
  database transaction.

  Pro: Injection can use 100% of the database server. It's no longer a
  bottleneck. If the database server has 16 CPUs, then we can use 16 CPUs
  for whatever load we have. No locks can cause CPUs to sit around
  waiting (almost).

  Contra: For a short while, uidnext has moved but the message has not
  appeared in the database. In that time, the imapd can currently infer
  that the message has existed and been expunged, which sits badly with
  imap caching semantics. But I think we can deal with that, e.g. by
  saying that ocd is updated last, and a lower value seen via ocd wins
  over a higher value in the database. Something like that.


When TlsServer dies, imaps (993) must go away

  It doesn't at the moment. Anything else?


Faster mapping from unicode to 8-bit encodings

  At the moment, we use a while loop to find the right codepoint in an
  array[256]. Mapping U+00EF to latin-1 requires looping from 0 to
  0xEF, checking those 239 entries.

  We could use a DAG of partial mappings to make it faster. Much
  faster. Mapping U+20AC to 8895-15 would require just one lookup: In
  the first partial table for 8859-15. Mapping U+0065 to 8859-15 would
  require three: In the first (U+20AC, one entry long), in the
  fallback (U+00A0, 96 entries long) and in the last (U+0000, 160
  entries long).

  Effectively, 8859-15 would be a first table of exceptions and then
  fall back to 8859-1.

  The tables could be built automatically, compiled in, and would be
  tested by our existing apparatur.


We sometimes prefer KOI8-R in dubious circumstances.

  See o/22 (/tlan@stud.ntnu.no).


Multipart/signed automatic processing

  We could check signatures automatically on delivery, and reject bad
  signed messages.

  The big benefit is that some forgeries are rejected, even though the
  reader and the reading MUA doesn't do anything different.

  The disadvantage is that we (probably?) can't verify all signatures,
  which gives a false sense of security for the undetactable forgeries.

  In case of PKCS7, it's possible to self-sign. Those we cannot
  check. In that case we remove the signature entirely from the MIME
  structure, so it doesn't look checked to the end-user.

  PGP cannot be checked, except it sort of can. We can have a small
  default keyring including the heise.de CA key and so on, and treat
  that as root CAs, using the keyservers to dig up intermediate keys.


PGP automatic processing

  Apparently there are five different PGP wrapping formats. We could
  detect four and transform them to the proper MIME format.


imap/hackedsize#2 doesn't work.

  - The Received field added by smtpd changes.
  - The x-obliterate breaks ocd, so the select response is weird.


LDAP server/address book

  Joins rock. We can join ALL OUR TABLES and get INCREDIBLE
  FLEXIBILITY AND POWER.

  LDAP AB can provide several address books based on the archive:

   - all addresses visible anywhere
   - all addresses in your mailboxes
   - all addresses in mailboxes to which your groups have access
     (the join for this is a little hard)
   - all v-card bodyparts
   - all v-cards in your mailboxes
   - all v-cards in mailboxes to which your groups have access
     (I suppose one might even say "breathtakingly complex join")

  Admins can enable/disable each of those depending on site policy.


Groups and ACL

  We don't need groups as of now, but they do have their handy-dandy
  aspects. If we add groups, see the LDAP AB item.


