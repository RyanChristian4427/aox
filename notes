2.06: 2008-01-14

  Add some monitoring variables, whatever seems like a good idea.

  rrdtool integration script

  The great schema change. Remaining work:

  - Update the permissions test at startup. Not sure what it should
    test in the GNS.

  Done:
    - SORT
    - an EGD implementation to help Cryptlib with entropy. Should make
      STARTTLS faster, particularly on freebsd 5 and macosx.

  2007-12-07: decide on feature list
  2007-12-31: drop things that can't be finished
  2008-01-07: fork and remove unusable code
  2008-01-10: roll, release chores
  2008-01-11: features for next release
  2008-01-14: release


2.07: 2008-02-18

  Five weeks after 2.06.


Release cycle

  Five weeks, t-35 to t (a Monday).

  t-38: we decide on a feature list for the release.

  t-14: Whatever hasn't been started is dropped, whatever cannot be
  completed before t-7 is laid aside for the next release. Write the
  announcement text.

  t-7: Fork the release and remove any code that needs to be removed.

  t-4: Roll the tarball and do the release chores.

  t-3: See t-38 above.

  t-0: A crontab does what it needs to do.


The value of features

  Archiveopteryx provides online archiving. We want the features we
  add to improve one or more of these:
  - adding mail to the archive
  - accessing the archive
  - managing the archive

  For nontechnical reasons I add a fourth goal:
  - making current users happy

  Each new feature should help in some way; the new features that help
  the most are the ones we need most (in the long term - in the short
  term we also need to help existing users).


The next eight months

  - Message retention
      User interface
      Message identification
      Logging changes to the message
  - aoximport improvements
  - Full text search
  - More documentation
      aox operations guide
      best practice papers
  - Better documentation
  - VIEW improvements
      INTHREAD
      multi-mailbox searches
      miscellaneous
  - Account management
      ACL management
      VIEW management
  - Recording the fate of outgoing mail
  - Proper full-text searching
  - Better exploratory search
  - Useful webmail
  - Address search
      Web UI
      IMAP X-extension
      Exporting to addressbooks
  - Monitoring
      Graphing


Items for web site

  In addition to stuff in the operations guide:

  - List/description of IMAP/POP/SMTP extensions
  - RFC pages
  - man pages (old ones too)
  - Source documentation
  - Best practices
  - FAQ
  - Version-specific pages
  - Download-specific pages
  - Client-specific pages


Installer doesn't take steps to ensure that the installation is usable

  It could do at least two things:

  Run all the same checks on the new installation as 'aox check' and
  archiveopteryx at startup.

  Try to connect to all the server addresses and if anything's
  listening anywhere, mention it on stdout.

  In addition to this, the installer does the wrong thing right now if
  it creates the database users and then fails to run psql to load the
  schema. It exits with an error, which means the randomly-generated
  passwords are lost, because the configuration file is not written.


Various TODO items from earlier releases.

  Message retention policy

  - Soft-quota/archival stuff too?
  - Message arrival tag (for archiving)

  aoximport could be much faster (disable indices, commit several
  thousand messages at a time in one big transaction), but it's a fair
  bit of work (unless aoximport has a private Injector or Injector can
  take a list of Message objets)

  Miscellaneous:

  - Database replication support (local mirror)
  - Split the injector transaction into fast and slow parts(?)

  THREAD?

  Basic administration using the httpd

  Indexing for DOC bodyparts

  aox backup/restore (or similarly helpful procedure)

  Full-text search


Not enough name resolution: db-address=localhost doesn't work.

  The name is resolved at startup, but nothing ever calls the resolver
  to retrieve the value. One way to fix this would be to make Endpoint
  itself accept names and resolve them. The downside is: what if there
  are multiple addresses, e.g. 127.0.0.1 and ::1?

  There are three cases, perhaps four:

  - Our own servers, where it's clear what should happen, and
    Listener::create() does the right thing.
  - Outgoing connections where we need a connection to any address.
  - Outgoing connections where we need a connection to each address.
  - Outgoing connections where >1 addresses is not meaningful, not
    tested or otherwise undesirable.

  Each user of Endpoint needs to handle this. That's Listener,
  Database, LogClient and OcClient, right? (SpoolManager/SmtpClient need
  to resolve an Endpoint too. bin/aox needs to be able to connect to the
  same things the Listener decides to listen to.)


Cleartext passwords

  We help migrating away from cleartext/plaintext passwords:

  1. We also store SCRAM and similar secrets in the DB (secrets which
     aren't password equivalents)
  2. We extend the users table with two new columns, 'last time
     cleartext was needed' and 'number of successful authentications
     without cleartext password usage since cleartext'.
  3. If a client uses SCRAM, we increment the counter.
  4. If a client uses CRAM or PLAIN, we reset counter and set the time
     to today.
  5. We provide some helping code to delete passwords for users with a
     high count and a long-ago time.
  6. We add documentation saying that if you disable auth-this and
     auth-that, you can disable store-plaintext-passwords.
  7. We add configuration/db sanity checks for ditto.


Login failures

  We want to log those a little more, and show them on the
  webmail/admin pages.

  Specifically, if user x cannot log in, what mechanism was used, what
  was the problem, etc?


aox check schema

  This command would check several things.

  a) that dbuser has the needed rights
  b) that all the right tables are there, and all the right columns,
     with the right types, and no unexpected constraints
  c) that all the right indexes are there
  d) that dbowner owns everything
  i) that inserts that would duplicate a constraint are properly
     recognised

  As a bonus, perhaps it could list some unexpected/unknown deviations:
  e) locally added tables
  f) locally added columns
  g) locally added indices
  h) missing constraints


Database schema range

  Poeple occasionally need to access the db with an old version of
  mailstore. I suggest that we:

  a) add a 'writable_from' column specifying the oldest version that
     can write to the database.
  b) add a 'readable_from' column specifying the oldest version that
     can read the database

  aox upgrade schema would update writable_from to the oldest schema
  version for which a writer would do the right job. This would often
  change when a table changes, but not when a table is added.

  readable_from would be the oldest revision that can read the database.

  When the server starts up, it would check:

  - am I >writable_from? If so, mailboxes can be read-write
  - else, am I >readadble_from? If so, startup can proceed, but all
    mailboxes are read-only. lmtp, smtp and smtp-submit do not start.
  - else, quit.

  And in order to handle database updates, I suggest another table,
  'features', with a single string column. When aox update database
  fixes something, it inserts a row into features. A modern database
  would have two rows in this table, 'numbered address fields' and 'no
  nulls in bodyparts'.


Sieve

  Alexey suggests the following extensions (in the following order):
  Vacation, reject, imapflags, subaddress.

  We still haven't done imapflags.

  Reject probably has changed since we implemented it.


Better caching.

  FieldNameCache etc. can use less memory by reading all field and
  flag names into RAM at startup. That way, the memory used won't be
  scattered across many blocks.


RFCs 2852 and 4865

  Easy to do once we have port 587; we need to set the start and end
  columns right, that's about it.


Message tracking

  RFCs 3885-8 specify ways to track messages that have been sent. We
  can implement that fairly easily.

  If we route outgoing mail via a smarthost, that smarthost has to
  support MTRK in order for tracking to work well.

  We can track mail provided that at least one of these is true:

  - we deliver directly to the end server (looking at received fields
    for mail from the same address can help ascertain that the best mx
    really is that)

  - we deliver via an MTRK-capable server

  - we deliver into our own database

  Sounds likely to be true maybe 80-90% of the time.

  If none are true, we can at least say, easily, where we delivered,
  when, and why.

  We could implement the tracking protocol (and I'd write a query blah
  in mailchen), and also provide a query interface via the web.


Thread-Index from Exchange

  We could look at Thread-Index and reconstruct In-Reply-To in order to
  properly thread messages we a) aoximport from Exchange, or b) receive
  during a conversation with an Exchange user.


Bounces and DSNs

  Mail is currently fairly reliable. There is one big exception:
  Bounces aren't 100% parsable. But generally, if you work hard, you
  can know whether a message was delivered or not, and mostly they are
  delivered.

  So we benefit from converting the most common nonstandard bounces to
  DSNs, and then treat them as DSNs.

  For nonstandard bounces (like those of qmail) we identify the
  message by trying hard, do some hacky parsing, use the bounce
  (excluding trailing message) as first part of the DSN multipart,
  cook up a new DSN report based on the parsing, and save
  text/822-headers as a third part.

  Then, searches that tie bounces together with messages sent work
  even better.

  (Another trick we can/should use is to see whether the host we
  deliver to seems to be the final destination based on earlier
  (answered) messages.)


Memory use for common operations

  Some use _vastly_ too much memory. I saw a single IMAP FETCH for a
  mere 4200 messages use 173MB yesterday. (Later note: This should be
  gone, gone, gone, but it would still be good to check that these
  problems don't reappear, reappear, reappear.)

  The most elegant way to solve that would be to supervise memory
  usage for a known sequence. Inject these ten thousand messages,
  check memory use (via a hack), connect to the imap port run this and
  that, check again, connect to the imap port run this and that, check
  again, connect to the imap port run this and that, check
  again... just a bunch of checks. Ignore output.


Deleting mailbox has unclear semantics now

  At present, we don't allow a mailbox to be deleted until all
  undeletable messages from that mailbox have been sent to the great
  mailbox in the sky.

  We might want to change that, but what then? What if someone wants
  to rename a new mailbox to the name that used to be taken by this
  mailbox? Or creates ditto? What should happen to views onto this
  mailbox?


3.0 changes

  - Don't announce digest-md5 by default.
  - PIDFILEDIR should be $(PREFIX)/lib/pidfiles.


MULTIAPPEND

  Stupid thing. Clients and servers using pipelining can do the same
  thing.

  But there it is, and change 52791 shows that if the injector learns
  to inject many addresses at at time, multiappend can be used to
  inject lots of messages quickly.

  aoximport can do it even better, of course.


imapd/handlers/acl.cpp

  Different tasks, some shared code, same file. Separate this out into
  different classes inheriting something. Then add the right sort of
  logging statement to the end of parse().


Opera often can't expunge

  Trace it once or twice, guess what's wrong.


ocd needs work (mike@waspfactory.org)

  1. The code (along with user/mailbox) needs cleaning up.
  2. Should synchronise field names etc.


AddressCache and FieldNameCache are utter crocks, and must die.


aox/conf/*

  Possible category pages, each listing all variables that influence
  blah

  conf/encryption
  conf/authentication
  conf/webmail
  conf/submission
  conf/imap
  conf/database

  More?


aox/conf/tls-certificate

  Those variables are not well described. We need a bit more.

  Also, -secret is probably misnamed, we use -password for other
  cases. I expect that's why aox show cf tls-certificate-secret yields
  while e.g. aox show cf db-password does not.


METADATA

  Needed for lemonade, as easy as annotate.


Autoresponder

  We have vacation now, but it isn't quite right for autoresponses.
  Sieve autorespond should be like this:

  1. :quote should quote the first text/plain part if all of the
     following are true:

     1. The message is signed, and the signature verified (using any
        supported signature mechanism, DKIM SHOULD be supported).
     2. The first text/plain part does not have a Content-Disposition
        other than inline.

     If any of the conditions aren't true, :quote shouldn't quote.

     If there's a signature block, :quote shouldn't quote that.

     If the quoted text would be more than ten lines, :quote may crop
     it down as much as it wants, ideally by skipping lines starting
     with '>', otherwise by removing the last lines.

  2. :subject, :from and :addresses as for vacation.

  3. :cc can be used to send a copy to the specified From address.

  4. The default :handle should not be based on the quoted text.

  5. Two text arguments, one for text before the quoted text, one for
     text after the quoted text.

  6. The autoresponse goes to the envelope sender, as some RFC
     requires. So we want an option to skip the response unless the
     return-path matches reply-to (if present) or From (unless
     reply-to is present).


Message arrival tag

  Once annotate is done, we want a tag, ie. a magic annotation which
  stays glued to the message wherever it goes, even after copy/move.

  We also want a way to store the original RFC822 format somewhere
  inside and/or outside the database, indexed by the arrival tag
  identifier. It's good if the tag is split, so we can have "x-y"
  where X is the CD/DVD number and Y is the file on the CD/DVD. Or
  something like that.


Message Retention Policy Framework

  A lot of sites will want explicit policies regarding what mail may
  not be deleted, what may be deleted, and what must be deleted. We
  can support that well.


C/R

  C/R sucks. But it has its uses, so we can benefit from implementing
  it somehow. Here are some classes of messages we may want to treat
  specially:

  - replies to own mail
  - messages in languages not understood by the user
  - mail from previously unknown addresses
  - mail from freemail providers
  - vacation responses from unknowns
  - messages likely, but not certain to be out-of-office-autoreply
  - dkim/mass-signed messages (if verified)

  The questions are: How can we ensure that we almost never challenge
  real mail, while simultaneously challenging most/all messages that
  don't come from valid senders? How can we provide suitable
  configuration?


Using rrdtool

  What could we want to graph with rrdtool? Lots.

  - CPU seconds used
  - database size
  - messages in the db
  - average response time
  - 95th percentile response time
  - messages injected
  - messages per user
  - message size per user
  - logged-in users
  - average query execution time
  - average query queue size

  More?

  The natural way to do it would be to have archiveopteryx collect
  some/most variables in RAM, and provide a query via aox+ocd. some
  things (messages/message size per user at least) are better done as
  a db query from aox directly.

  'aox show statistics'?

  http://jwatt.org/svg/authoring/ is interesting for generating graphs
  via the web interface.


SASL NTLM authentication

  It may be odd and undocumented, and it may not be as strong as
  DIGEST-MD5, but it's implemented in Certain Clients ;)

  http://www.innovation.ch/java/ntlm.html seems to be a reasonable
  description. Cyrus also implements it.

  http://davenport.sourceforge.net/ntlm.html ?


DELETE of mailboxes in inappropriately qualified (security problem)

  At present, the user always needs to have all three rights, and
  there's a race condition against append/copy. It would be better to
  grab the uidnext lock and do more fine-grained checking:

  1. Require DeleteMessages unless all messages have \deleted.

  2. Require Expunge if there are any messages at all.

  The race condition means it's possible to append to a mailbox while
  it's being deleted, and the message will reappear if the mailbox is
  later recreated. We could solve the latter by emptying the mailbox
  at recreate time.


Split the folder view into pages.

  Need to decide on what a page is. "Most recent 25 threads" is a
  slippery concept when a new thread is created between page views.


Write better field wrapping code

  HeaderField::wrap is terribly hackish right now. Besides, ::unwrap()
  should become the higher-level parser's job.


We should be able to use a read-only local database mirror.

  That way, we can play nicely with most replication systems.

  The way to do it: add a new db-mirror setting pointing to a
  read-only database mirror. all queries that update are sent to
  db-address, all selects are sent to db-mirror. db-mirror defaults to
  db-address.


Add Maildir support to the migrator.

  Currently works, with two exceptions: Submaildirs don't work, and
  courier's extended flags don't work.


We should test multipart/signed and multipart/encrypted support.

  We must add a selection of RFC 1847 messages to canonical, and make
  sure they survive the round trip. No doubt there will be bugs.


We should store bodyparts.text for PDF/DOC.

  We need non-GPLed code to convert PDF and DOC to plaintext.

  Or maybe we need a generic interface to talk to plugins.


Switch to using named constraints everywhere.


Default c-t-e of PGP signatures

  Right now we give them binary. q-p or 7bit would be better, I think.

  What other application/* types are really text?

  From a conversation the other day: we could avoid base64 encoding an
  entity whose content-type is not text if it contains only printable
  ASCII. I don't know if it's worth doing, though.

  The problem with doing that is that it treats sequences of CR LF, CR
  and LF as equivalent. An application/foobar object that happens to
  contain only CR, LF and printable ASCII can be broken.


Something like soft-bounce might just be useful

  enabled: smtp/lmtp always give 4xx errors. disabled: either 4xx or
  5xx depending on the type of error.


recognising spam

  The good spam filters now all seem to require local training with
  both spam and nonspam corpora. We can do clever stuff... sometimes.

  Instead of filtering at delivery, we can filter when a message
  becomes \recent. When we increase first_recent, we hand each new
  message to the categoriser, and set $Spam or $Nonspam based on its
  answer.

  This lets the categoriser use all the information that's available
  right up to the moment the user looks at his mail.

  We can also build corpora for training easily. All messages to which
  users have replied are nonspam, replies to messages from local users
  are nonspam, messages in certain folders are spam, messages with a
  certain flag are spam.

  We can connect to a local server to ask whether a message is spam.
  They seem to work that way, but with n different protocols.


Replace Mailbox::isHome with something correct.

  It should look for a mailbox whose owner is different from its
  parent's owner.


TLS client support (smtp, postgresql)


"Writing Secure Code"

  We have a page about security, /mailstore/security.html, and a
  section of the mailstore.7 man page mentions it too.

  We need to look at ISBN 0735617228 and improve security.html with
  points from it. It could also be that we'll improve the code itself.


udoc stuff:

  1. Support a single level of nested classes. (What file names to use
     for output?)
  2. Support enum annotation.
  3. Suppress empty <p>, duplicate anchor names in output.


Udoc web pages chores

  Add "Related Pages" etc. Clarify where background.html
  fits. usage.html is an orphan now; should it become a manpage?


Play with PITR and write /ams/pitr.html


Document IPC structure

  Some man page, or some web page, or both, should say who's
  connecting to who and why.


Add a web page about the charset encoding.

  It's a novel and good algorithm, so we can make a good page about
  it. We also can link to data sources there.

  The documentation for Codec::byString() should mention that page's
  URL.


Make a web page about our licensing

  Not sure what to say there. the purpose of the page would be to
  direct people to one of the two others, really. and to be linked to
  from the home page.


The "Database" link on home page

  Where should it go? People might click it wondering why to use a
  database instead of flat files and wanting to know what we do with
  databases.


Interop pages

  A variety needed.


Protocols supported

  A list detailing what our general idea is (internet standard,
  interoperability, utility) and linking to each actual protocol page.

  The URL for this is difficult.


Search ourselves, not via google

  Or maybe farm that out, get google to search with an approximation
  of our design. http://www.google.com/faq_freewebsearch.html may be
  interesting.


Fix shutdown

  There's no practical way to shutdown using ocd/ocadmin. Perhaps this
  is another aspect of the problem above.


Logging to syslog

  logfile=syslog:local2 could mean "log to syslog with the local2
  facility". that's ugly syntax. parsing and blah.

  if we implement this, the logd HUP handler can switch to syslog if
  it can't reopen the logfile.


Rendering webmail HTML is presumably good, but...

  Knowledge is better than presumption.

  Webmail services have a lot of known holes. Cross site scripting and
  suchlike. We can add known sploits/demos to our rendering tests, and
  check that we're not vulnerable.

  We have a potential security hole: A malevolent HTML bodypart is
  forwarded as is on the "download bodypart" page.


When TlsServer dies, imaps (993) must go away

  It doesn't at the moment. Anything else?


Faster mapping from unicode to 8-bit encodings

  At the moment, we use a while loop to find the right codepoint in an
  array[256]. Mapping U+00EF to latin-1 requires looping from 0 to
  0xEF, checking those 239 entries.

  We could use a DAG of partial mappings to make it faster. Much
  faster. Mapping U+20AC to 8895-15 would require just one lookup: In
  the first partial table for 8859-15. Mapping U+0065 to 8859-15 would
  require three: In the first (U+20AC, one entry long), in the
  fallback (U+00A0, 96 entries long) and in the last (U+0000, 160
  entries long).

  Effectively, 8859-15 would be a first table of exceptions and then
  fall back to 8859-1.

  The tables could be built automatically, compiled in, and would be
  tested by our existing apparatus.


Multipart/signed automatic processing

  We could check signatures automatically on delivery, and reject bad
  signed messages.

  The big benefit is that some forgeries are rejected, even though the
  reader and the reading MUA doesn't do anything different.

  The disadvantage is that we (probably?) can't verify all signatures,
  which gives a false sense of security for the undetactable forgeries.

  In case of PKCS7, it's possible to self-sign. Those we cannot
  check. In that case we remove the signature entirely from the MIME
  structure, so it doesn't look checked to the end-user.

  PGP cannot be checked, except it sort of can. We can have a small
  default keyring including the heise.de CA key and so on, and treat
  that as root CAs, using the keyservers to dig up intermediate keys.


PGP automatic processing

  Apparently there are five different PGP wrapping formats. We could
  detect four and transform them to the proper MIME format.


Plugins

  It's not given that we want to accept all mail. If we don't, who
  makes the decision? A sieve script may, and refuse/reject mail it
  does not like. And a little bit of pluginnery may. I think we'd do
  well to support the postfix plugin protocol, so all postfix policy
  servers can work with aox. (All? Or just half? Doesn't postfix have
  two types of policy plugins?)

  We may even support site-wide and group-wide sieve scripts and
  permit a sieve script to invoke the plugin. A sieve statement like
  this?

     UsePolicyServer localhost 10023 ;


BURL

  If the message is multipart and the boundary occurs in a part, that
  part needs encoding. Or else switch to a different body.


NOTIFY implementation

  Going there...


Cybertec replicator

  Is it good? What are people saying about it? What should we do about it?

  Ewald Geschwinde on IRC (the first time I've seen him; 2007-07-11) said:
  *egeschwinde* When I have time I will test your product on our
  multimaster cluster
  *egeschwinde* maybe also on the queuing system


DIGEST-MD5 reauth doesn't work for Dave Cridland

  (I haven't tried to reproduce it yet, because Polymer needs more
  Python stuff installed than I had the patience for.)


Delaying seen-flag setting

  We can move the seenflagsetter to imapsession, build up flags to
  set, flush the write cache before fetch flags, store, state-altering
  commands and searches which use either modseq or flags.

  This ought to cut down the number of transactions issued per imap
  command nicely.


The web interface should offer a download link for attachments.

  For patches attached as text/plain with the right Content-Disposition,
  for example.


Per-group and systemwide sieves

  People always seem to want such things. It'll be easy to implement.
  Most of the tricky issues are described in
  http://tools.ietf.org/html/draft-degener-sieve-multiscript-00


The Sieve "header" test may fail

  Write a test or three that feeds the thing a 2047-encoded header
  field and checks that it's correctly matched/not matched. Then make
  it pass.


The subaddress specification says foo@ != foo+@ wrt. :detail

  The former causes any :detail tests to evaluate to false, while the
  latter treats :detail as an empty string. We treat both as an empty
  string.

  (We could set detail to a single null byte, to \0\r\0\n\0, to a
  sequence of private-use unicode characters, or even to
  Entropy::string( 8 ) if there is no separator. The chance of that
  appearing in an address is negligible.)


Distribution packages

  - RPM: silug has offered to help.
  - FreeBSD port: devin (Tod McQuillin) has offered to help.
  - Debian: ? (license problems, but we could provide a .deb).
  - Ubuntu: ?


SMTP extensions

  Here are the ones we still don't implement, but ought to implement
  at some point:

  SUBMITTER? perhaps
  DELIVERBY (RFC 2852): At some time.
  FUTURERELEASE (RFC 4865): At some time.
  MTRK: As soon as someone else does it.

  http://www.iana.org/assignments/mail-parameters


SUBMITTER

  The work needed to support that:

  1. Pass a submitter to SmtpClient.
  2. Pass the sieve owner or logged-in user's address as submitter.
  3. Send that as SUBMITTER= if the smarthost advertises SUBMITTER and
     the submitter is different from mail-from.

  4. Advertise SUBMITTER.
  5. If the SMTP/LMTP/Submit client sends SUBMITTER and it's different
     from the mail-from, record the address in Received.
  6. If there's a sieve extension specifying how, push the submitter
     into the envelope so the sieve can see it.

  Easy peasy. But there's no value to offset this (small) cost, is
  there? Maybe as a hack when one of us is fed up.


SSL/TLS hello

  When a client sends us SSL or TLS hello instead of the appropriate
  protocol, wgat do we want to do? Two options:
  - Silently start TLS.
  - Send some sort of server hello saying "no, my friend"

  Connection could have a utility function to look at whether the next
  few bytes on the incoming connection match a TLS/SSL hello, and each
  subclass could make the choice for itself. I think the real
  protocols would want to say no, and HTTP might want to do something
  else.


The groups and group_members tables seem a little underused

  We do not use them at all. We meant to use them for "advanced" ACL
  support, but nobody ever asked, and it didn't seem worthwhile.

  I now think it's worthwhile.

  Here's what I want to add:

  Make a superusers group, which members can authenticate as anyone,
  and the notion of group admins, who can authenticate as other
  members of the group.

  Or maybe an adminintrator table, linking a user to either a group or
  to null. If a group, then the admin can authenticate as other
  members of that group and (importantly) has 'a' right on their
  mailboxes, if null, then ditto for all groups.

  Extend Permissions to link against group_memebers when selecting
  applicable permissions.

  Make groups be permissible ACL identifiers.


Better error messages

  Map from "blah blah addresses_nld_key" to "The operation would create
  a duplicate email address" and similarly for other constraints. This
  will allow aox to print more useful error messages than to just dump
  the server message onto the user.


We need to be able to disable users

  - Reject mail with 5xx/4xx.
  - Prevent login.
  - 1+2.
  - a group admin can enable/disable group members
  - a superadmin can enable/disable anyone
  - a group admin cannot unblock an overall blockage


Using whirlpool instead of MD5.

  I get the impression that conventional opinion is slowly moving
  towards whirlpool as the hash function of choice. At some point we
  want to use it instead of MD5 for the bodyparts table.

  I don't want to use SHA* functions, they're too similar to
  MD5. Those aren't worth the move.

  Two ways to move to Whirlpool:

  1. Recompute all the hashes and update the table.

  2. Just start inserting whirlpool hashes in the hash column, and
     accept that if the same bodypart was inserted by an older
     version, we'll store it twice.

  I don't want to bother with the expensive rehashing. But maybe
  people will be unhappy and ask us to do it as an aox command.

  It seems that netbsd includes a whirlpool implementation.


Assigning the "l" right automatically hurts shared hosting.

  Casey Shobe <casey@shobe.info> wants to host multiple customers in a
  single Archiveopteryx installation, and doesn't want them to be able
  to see each other's mailboxes. We could support that now (2008-01).


Showing email addresses in public archives is... well...

  There are three common solutions:

  1. Show the address. What we do now. Gives addresses to spammers,
     which is undesirable.

  2. Replace @ with at or some other easily reversible change. I
     assume gigamega.com, litefinder.net and other address scrapers
     already detect the common obfuscations, so this is pointless.

  3. Show part of the address, e.g. arnt@ory... or
     ar...@oryx.co... for arnt@oryx.com. Isn't reversible, so the
     spammers can't undo it, but also makes the archive less usable
     for people.

  We might change to 3, but with a captcha-protected option to show
  1. That would give us all the advantages and no serious disadvantage.
  But we would have to implement captchas somehow, which would be a
  moderate pain.


