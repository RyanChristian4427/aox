-- This table contains information internal to the mailstore.
-- For now, its only purpose is to coordinate schema updates.

create table mailstore (
    revision    integer not null
);
insert into mailstore (revision) values (25);


-- One entry for each unique address we've encountered.

create table addresses (
    id          serial primary key,
    name        text,
    localpart   text,
    domain      text,
    unique (name, localpart, domain)
);


-- One entry per "other users" namespace. Personal namespaces are
-- implicitly created within these.

create table namespaces (
    id          serial primary key,
    name        text not null unique
);
insert into namespaces (name) values ('/users');


-- One entry per Archiveopteryx user.
-- Used for authentication, access control, and mail routing.

create table users (
    id          serial primary key,
    login       text unique,
    secret      text,
    parentspace integer not null references namespaces(id)
);


-- One entry per named group.

create table groups (
    id          serial primary key,
    name        text
);


-- One entry for each group member.

create table group_members (
    groupname   integer not null references groups(id),
    member      integer not null references users(id)
);


-- One entry per deliverable mailbox.

create table mailboxes (
    id          serial primary key,
    name        text not null unique,
    owner       integer references users(id),

    -- The UID that will be assigned to the next delivered message.
    -- Incremented after each successful delivery.
    uidnext     integer not null default 1,

    -- The UID of the first message that should be marked \Recent.
    -- Set to uidnext when each new IMAP session is created.
    first_recent integer not null default 1,

    -- The IMAP mailbox UIDVALIDITY value, which, along with a message UID,
    -- is forever guaranteed to uniquely refer to a single message.
    uidvalidity integer not null default 1,

    -- When a mailbox is deleted, its entry is marked (not removed), so
    -- that its UIDVALIDITY can be incremented if it is ever re-created.
    deleted     boolean not null default false
);


-- One entry per delivery alias: mail to the given address should be
-- accepted and delivered into the given mailbox.

create table aliases (
    id          serial primary key,
    address     integer not null unique references addresses(id),
    mailbox     integer not null references mailboxes(id)
                on delete cascade
);


alter table users add alias integer references aliases(id);
alter table users alter alias set not null;


-- One row per <identifier, right> entry for a mailbox.

create table permissions (
    mailbox     integer not null references mailboxes(id),
    identifier  text not null,
    rights      text not null
);


-- One (mailbox, uid) entry per delivered message.

create table messages (
    mailbox     integer not null references mailboxes(id),
    -- Assigned from the mailbox uidnext value.
    uid         integer not null,
    -- Delivery time in seconds since the epoch.
    idate       integer,
    -- Message size in bytes (to speed up FETCH).
    rfc822size  integer,
    primary key (mailbox, uid)
);


-- One entry for the text of each unique MIME body part.
-- Entries here may be shared by more than one message.

create sequence bodypart_ids;
create table bodyparts (
    id          integer default nextval('bodypart_ids') primary key,
    bytes       integer not null,
    hash        text not null unique,
    text        text,
    data        bytea
);


-- A list of bodyparts belonging to each message, with IMAP part numbers.

create table part_numbers (
    mailbox     integer not null,
    uid         integer not null,
    part        text not null,
    bodypart    integer references bodyparts(id),
    bytes       integer,
    lines       integer,
    foreign key (mailbox, uid)
                references messages(mailbox, uid)
                on delete cascade,
    primary key (mailbox, uid, part)
);


-- One entry for each field name we've seen (From, To, Subject, etc.).
-- (This table is partially populated from the field-names file.)

create table field_names (
    id          serial primary key,
    name        text unique
);


-- A list of the header fields associated with each bodypart in a message.

create table header_fields (
    id          serial primary key,
    mailbox     integer not null,
    uid         integer not null,
    part        text not null,
    position    integer not null,
    field       integer not null references field_names(id),
    value       text,
    unique (mailbox, uid, part, position, field),
    foreign key (mailbox, uid, part)
                references part_numbers(mailbox, uid, part)
                on delete cascade
);
create index hf_mup on header_fields (mailbox, uid, part);


-- A list of addresses associated with each message.

create table address_fields (
    mailbox     integer not null,
    uid         integer not null,
    part        text not null,
    position    integer not null,
    field       integer not null,
    address     integer not null references addresses(id),
    foreign key (mailbox, uid, part, position, field)
                references header_fields(mailbox, uid, part,
                position, field) on delete cascade
);
create index af_mu on address_fields (mailbox, uid);


-- The Date field from each message.

create table date_fields (
    mailbox     integer not null,
    uid         integer not null,
    value       timestamp with time zone,
    foreign key (mailbox, uid)
                references messages(mailbox, uid)
                on delete cascade
);


-- One entry per unique thread.

create table threads (
    id          serial primary key,
    mailbox     integer not null references mailboxes(id),
    subject     text unique
);


-- One entry per message in each thread.

create table thread_members (
    thread      integer not null references threads(id),
    mailbox     integer not null,
    uid         integer not null,
    foreign key (mailbox, uid)
                references messages(mailbox, uid)
                on delete cascade
);


-- One entry per user-defined flag name to be used in flags.

create table flag_names (
    id          serial primary key,
    name        text
);
create unique index fn_uname on flag_names(lower(name));


-- One entry per user-defined IMAP message flag per message.

create table flags (
    mailbox     integer not null,
    uid         integer not null,
    flag        integer not null references flag_names(id),
    foreign key (mailbox, uid)
                references messages(mailbox, uid)
                on delete cascade
);
create index fl_mu on flags (mailbox, uid);


-- One entry per subscribed mailbox per user.

create table subscriptions (
    id          serial primary key,
    owner       integer not null references users(id)
                on delete cascade,
    mailbox     integer not null references mailboxes(id)
);


-- One entry per vendor- or RFC-defined name to be used in annotations

create table annotation_names (
    id          serial primary key,
    name        text unique
);

-- One entry per annotation

create table annotations (
    mailbox     integer not null,
    uid         integer not null,
    owner       integer references users(id) on delete cascade,
    name        integer not null references annotation_names(id),
    value       text,
    unique (mailbox, uid, owner, name),
    foreign key (mailbox, uid)
                references messages(mailbox, uid)
                on delete cascade
);

-- One entry per view: the view is a mailbox that contains the result
-- of applying the selector to the source mailbox.

create table views (
    id          serial primary key,
    source      integer not null references mailboxes(id)
                on delete cascade,
    view        integer not null references mailboxes(id)
                on delete cascade unique,
    -- We need to keep track of how far we've searched already.
    suidnext    integer not null,
    selector    text
);

-- One entry per message that belongs to a view: the (view,uid) maps to
-- the real message (source,suid).

create table view_messages (
    view        integer not null references views(view)
                on delete cascade,
    uid         integer not null,
    source      integer not null,
    suid        integer not null,
    foreign key (source, suid)
                references messages(mailbox, uid)
                on delete cascade
);


-- One entry per SIEVE script owned by a user.

create table scripts (
    id          serial primary key,
    owner       integer not null references users(id),
    name        text,
    active      boolean not null default 'f',
    script      text
);


-- One entry per deleted (EXPUNGEd) message.

create table deleted_messages (
    mailbox     integer not null,
    uid         integer not null,
    deleted_by  integer not null references users(id),
    deleted_at  timestamp with time zone not null
                default current_timestamp,
    reason      text,
    foreign key (mailbox, uid)
                references messages(mailbox, uid)
                on delete cascade
);


-- One entry per message, changeable by aox

create sequence nextmodsequence;
create table modsequences (
    mailbox     integer not null,
    uid         integer not null,
    modseq      bigint not null,
    foreign key (mailbox, uid)
                references messages(mailbox, uid)
);
